<!DOCTYPE html><html lang="en"><head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.35">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>OCaml - Effect Handlers</title>
<script src="scroll.js"></script><script src="navigation.js"></script><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></head>
<body><div class="content manual"><div id="sidebar-button"><span>☰</span></div><nav id="part-title"><span>☰</span>An introduction to OCaml</nav><ul id="part-menu"><li><a href="coreexamples.html">The core language</a></li><li><a href="moduleexamples.html">The module system</a></li><li><a href="objectexamples.html">Objects in OCaml</a></li><li><a href="lablexamples.html">Labeled arguments</a></li><li><a href="polyvariant.html">Polymorphic variants</a></li><li><a href="polymorphism.html">Polymorphism and its limitations</a></li><li><a href="gadts-tutorial.html">Generalized algebraic datatypes</a></li><li><a href="advexamples.html">Advanced examples with classes and modules</a></li><li class="active"><a href="effects-tutorial.html">Effect Handlers</a></li></ul>




<h1 class="chapter" id="sec79"><span class="chapter-number">Chapter 9</span> Effect Handlers</h1>
<header id="sidebar"><nav class="toc brand"><a class="brand" href="https://ocaml.org/"><img src="colour-logo.svg" class="svg" alt="OCaml"></a></nav><nav class="toc"><div class="toc_version"><a id="version-select" href="https://ocaml.org/releases/">Version 5.0</a></div><div class="toc_title"><a href="index.html">&lt; The OCaml Manual</a></div><ul><li class="top"><a href="#">Effect Handlers</a></li>
<li><a href="effects-tutorial.html#s%3Aeffects-basics"><span class="number">1</span> Basics</a>
</li><li><a href="effects-tutorial.html#s%3Aeffects-concurrency"><span class="number">2</span> Concurrency</a>
</li><li><a href="effects-tutorial.html#s%3Aeffects-user-threads"><span class="number">3</span> User-level threads</a>
</li><li><a href="effects-tutorial.html#s%3Aeffects-generator"><span class="number">4</span> Generators</a>
</li><li><a href="effects-tutorial.html#s%3Aeffects-semantics"><span class="number">5</span> Semantics</a>
</li><li><a href="effects-tutorial.html#s%3Aeffects-shallow"><span class="number">6</span> Shallow handlers</a>
</li></ul></nav></header>
<p> <a id="c:effects-tutorial"></a>
</p><p>Effect handlers are a mechanism for modular programming with user-defined
effects. Effect handlers allow the programmers to describe
<span class="font-it">computations</span> that <span class="font-it">perform</span> effectful <span class="font-it">operations</span>, whose
meaning is described by <span class="font-it">handlers</span> that enclose the computations. Effect
handlers are a generalization of exception handlers, and enable non-local
control-flow mechanisms such as resumable exceptions, lightweight threads,
coroutines, generators and asynchronous I/O to be composably expressed. In this
tutorial, we shall see how some of these mechanisms can be built using effect
handlers.</p>
<h2 class="section" id="s:effects-basics"><a class="section-anchor" href="#s:effects-basics" aria-hidden="true"></a><span class="number">1</span> Basics</h2>
<p>To understand the basics, let us define an effect that exchanges an integer,
and a computation that performs two exchanges and returns their sum.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> Effect
<span class="ocamlkeyword">open</span> Effect.Deep

<span class="ocamlkeyword">type</span> _ Effect.t += Xchg: int -&gt; int t
<span class="ocamlkeyword">let</span> comp1 () = perform (Xchg 0) + perform (Xchg 1)</div></div>

</div><p>We declare the exchange effect <span class="machine"><span class="font-tt">Xchg</span></span> by extending the pre-defined extensible
variant type <span class="machine"><span class="font-tt">Effect.t</span></span> with a new constructor <span class="machine"><span class="font-tt">Xchg: int -&gt; int t</span></span>. The
declaration may be intuitively read as “the <span class="machine"><span class="font-tt">Xchg</span></span> effect take an integer
parameter, and when this effect is performed, it returns an integer”. The
computation <span class="machine"><span class="font-tt">comp1</span></span> performs the effect twice using the <span class="machine"><span class="font-tt">perform</span></span> primitive and
returns their sum.</p><p>In this example, we use the deep version of the effect handlers here as opposed
to shallow version. The distinction between deep and shallow handlers is
discussed later in ‍<a href="#s%3Aeffects-shallow">9.6</a>.</p><p>We can handle the <span class="machine"><span class="font-tt">Xchg</span></span> effect by implementing a handler that always returns
the successor of the offered value:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">try_with comp1 ()
{ effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff: a t) -&gt;
    <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
    | Xchg n -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (a, _) continuation) -&gt;
        continue k (n+1))
    | _ -&gt; None }</div>



<div class="pre caml-output ok">- : int = 3</div></div>

</div><p><span class="machine"><span class="font-tt">try_with</span></span> runs the computation <span class="machine"><span class="font-tt">comp1 ()</span></span> under an effect handler that handles
the <span class="machine"><span class="font-tt">Xchg</span></span> effect. As mentioned earlier, effect handlers are a generalization
of exception handlers. Similar to exception handlers, when the computation
performs the <span class="machine"><span class="font-tt">Xchg</span></span> effect, the control jumps to the corresponding handler.
However, unlike exception handlers, the handler is also provided with the
delimited continuation <span class="machine"><span class="font-tt">k</span></span>, which represents the suspended computation between
the point of <span class="machine"><span class="font-tt">perform</span></span> and this handler.</p><p>The handler uses the <span class="machine"><span class="font-tt">continue</span></span> primitive to resume the suspended computation
with the successor of the offered value. In this example, the computation
<span class="machine"><span class="font-tt">comp1</span></span> performs <span class="machine"><span class="font-tt">Xchg 0</span></span> and <span class="machine"><span class="font-tt">Xchg 1</span></span>, and correspondingly receives the values
<span class="machine"><span class="font-tt">1</span></span> and <span class="machine"><span class="font-tt">2</span></span> from the handler. Hence, the whole expression evaluates to <span class="machine"><span class="font-tt">3</span></span>.</p><p>It is useful to note that the we need use locally abstract type <span class="machine"><span class="font-tt">(type a)</span></span> in
the effect handler. The type <span class="machine"><span class="font-tt">Effect.t</span></span> is a GADT, and the effect declarations
may have different type parameters for different effects. The type parameter
<span class="machine"><span class="font-tt">a</span></span> in the type <span class="machine"><span class="font-tt">a Effect.t</span></span> represents the type of the value returned when
performing the effect.</p><p>Another point to note is that the catch-all case “<span class="machine"><span class="font-tt">| _ -&gt; None</span></span>” is necessary
when handling effects. This case may be intuitively read as “forward the
unhandled effects to the outer handler”.</p>
<h2 class="section" id="s:effects-concurrency"><a class="section-anchor" href="#s:effects-concurrency" aria-hidden="true">﻿</a><span class="number">2</span> Concurrency</h2>
<p>The expressive power of effect handlers comes from the delimited continuation.
While the previous example immediately resumed the computation, the computation
may be resumed later, running some other computation in the interim. Let us
extend the previous example and implement message-passing concurrency between
two concurrent computations using the <span class="machine"><span class="font-tt">Xchg</span></span> effect. We call these concurrent
computations <span class="font-it">tasks</span>.</p><p>A task may either be in suspended state or is completed. We represent the task
status as follows:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> 'a status =
  Complete <span class="ocamlkeyword">of</span> 'a
| Suspended <span class="ocamlkeyword">of</span> {msg: int; cont: (int, 'a status) continuation}</div></div>

</div><p>The task may either have been <span class="machine"><span class="font-tt">Complete</span></span> with the result or is <span class="machine"><span class="font-tt">Suspended</span></span> with
the message <span class="machine"><span class="font-tt">msg</span></span> to send and the continuation <span class="machine"><span class="font-tt">cont</span></span>. The type <span class="machine"><span class="font-tt">(int, 'a status) continuation</span></span> says that the suspended computation expects an <span class="machine"><span class="font-tt">int</span></span>
value to resume and returns a <span class="machine"><span class="font-tt">'a status</span></span> value when resumed. It is useful to
note that, unlike undelimited continuations, when delimited continuations are
resumed, they return to the caller.</p><p>Next, we define a <span class="machine"><span class="font-tt">step</span></span> function that executes one step of computation until
it completes or suspends:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> step f () =
  match_with f ()
  { retc = (<span class="ocamlkeyword">fun</span> v -&gt; Complete v);
    exnc = raise;
    effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff: a t) -&gt;
      <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
      | Xchg msg -&gt; Some (<span class="ocamlkeyword">fun</span> (cont: (a, _) continuation) -&gt;
          Suspended {msg; cont})
      | _ -&gt; None }</div></div>

</div><p>Like <span class="machine"><span class="font-tt">try_with</span></span>, <span class="machine"><span class="font-tt">match_with</span></span> also introduces an effect handler. Unlike
<span class="machine"><span class="font-tt">try_with</span></span>, where only the effect cases <span class="machine"><span class="font-tt">effc</span></span> is provided, <span class="machine"><span class="font-tt">match_with</span></span>
expects the handlers for the value (<span class="machine"><span class="font-tt">retc</span></span>) and exceptional (<span class="machine"><span class="font-tt">exnc</span></span>) return
cases.</p><ul class="itemize"><li class="li-itemize">
Case <span class="machine"><span class="font-tt">retc</span></span>: If the computation returns with a value <span class="machine"><span class="font-tt">v</span></span>, we return
<span class="machine"><span class="font-tt">Complete v</span></span>.
</li><li class="li-itemize">Case <span class="machine"><span class="font-tt">exnc</span></span>: If the computation raises an exception, then the handler
raises the same exception.
</li><li class="li-itemize">Case <span class="machine"><span class="font-tt">effc</span></span>: If the computation performs the effect <span class="machine"><span class="font-tt">Xchg msg</span></span> with the
continuation <span class="machine"><span class="font-tt">cont</span></span>, then we return <span class="machine"><span class="font-tt">Suspended{msg;cont}</span></span>.
</li></ul><p>We can now write a simple scheduler that runs a pair of tasks to completion:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> run_both a b =
  <span class="ocamlkeyword">match</span> a (), b () <span class="ocamlkeyword">with</span>
  | Complete va, Complete vb -&gt; (va, vb)
  | Suspended {msg = m1; cont = k1},
    Suspended {msg = m2; cont = k2} -&gt;
      run_both (<span class="ocamlkeyword">fun</span> () -&gt; continue k1 m2)
               (<span class="ocamlkeyword">fun</span> () -&gt; continue k2 m1)
  | _ -&gt; failwith <span class="ocamlstring">"Improper synchronization"</span></div></div>

</div><p>Both of the tasks may run to completion, or both may offer to exchange a
message. In the latter case, we resume the computations with the value from the
other. We consider the other cases to be improperly synchronized programs.</p><p>We can now define a second computation that also exchanges two messages:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> comp2 () = perform (Xchg 21) * perform (Xchg 21)</div></div>

</div><p>Finally, we can run the two computations together:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">run_both (step comp1) (step comp2)</div>



<div class="pre caml-output ok">- : int * int = (42, 0)</div></div>

</div>
<h2 class="section" id="s:effects-user-threads"><a class="section-anchor" href="#s:effects-user-threads" aria-hidden="true">﻿</a><span class="number">3</span> User-level threads</h2>
<p>Let us extend the previous example to arbitrary number of tasks. Many languages
such as GHC Haskell and Go provide user-level threads as a primitive feature
provided by the runtime system. With effect handlers, user-level threads and
their schedulers can be implemented in OCaml itself. Typically, user-level
threading systems provide <span class="machine"><span class="font-tt">fork</span></span> primitive to spawn off a new concurrent task
and a <span class="machine"><span class="font-tt">yield</span></span> primitive to yield control to some other task. Correspondingly,
we shall declare two effects as follows:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> _ Effect.t += Fork : (unit -&gt; unit) -&gt; unit t
                 | Yield : unit t</div></div>

</div><p><span class="machine"><span class="font-tt">Fork</span></span> effect takes a thunk and returns a unit to the performer. <span class="machine"><span class="font-tt">Yield</span></span> effect
is unparameterized, and returns a unit when performed. Let us consider that a
task performing <span class="machine"><span class="font-tt">Xchg</span></span> effect may match with any other task also offering to
exchange a value.</p><p>We shall also define helper functions that simply perform these effects:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> fork f = perform (Fork f)
<span class="ocamlkeyword">let</span> yield () = perform Yield
<span class="ocamlkeyword">let</span> xchg v = perform (Xchg v)</div></div>

</div><p>A top-level <span class="machine"><span class="font-tt">run</span></span> function defines the scheduler:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* A concurrent round-robin scheduler *)</span>
<span class="ocamlkeyword">let</span> run main =
  <span class="ocamlkeyword">let</span> exchanger = <span class="ocamlkeyword">ref</span> None <span class="ocamlkeyword">in</span> <span class="ocamlcomment">(* waiting exchanger *)</span>
  <span class="ocamlkeyword">let</span> run_q = Queue.create () <span class="ocamlkeyword">in</span> <span class="ocamlcomment">(* scheduler queue *)</span>
  <span class="ocamlkeyword">let</span> enqueue k v =
    Queue.push (<span class="ocamlkeyword">fun</span> _ -&gt; continue k v) run_q
  <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> dequeue () =
    <span class="ocamlkeyword">if</span> Queue.is_empty run_q <span class="ocamlkeyword">then</span> () <span class="ocamlcomment">(* done *)</span>
    <span class="ocamlkeyword">else</span> (Queue.pop run_q) ()
  <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> spawn f =
    match_with f () {
      retc = dequeue;
      exnc = (<span class="ocamlkeyword">fun</span> e -&gt;
        print_endline (Printexc.to_string e);
        dequeue ());
      effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff : a t) -&gt;
        <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
        | Yield -&gt; Some (<span class="ocamlkeyword">fun</span> (k : (a, unit) continuation) -&gt;
            enqueue k (); dequeue ())
        | Fork f -&gt; Some (<span class="ocamlkeyword">fun</span> (k : (a, unit) continuation) -&gt;
            enqueue k (); spawn f)
        | Xchg n -&gt; Some (<span class="ocamlkeyword">fun</span> (k : (int, unit) continuation) -&gt;
            <span class="ocamlkeyword">begin</span> <span class="ocamlkeyword">match</span> !exchanger <span class="ocamlkeyword">with</span>
            | Some (n', k') -&gt;
                exchanger := None; enqueue k' n; continue k n'
            | None -&gt; exchanger := Some (n, k); dequeue ()
            <span class="ocamlkeyword">end</span>)
        | _ -&gt; None
    }
  <span class="ocamlkeyword">in</span>
  spawn main</div></div>

</div><p>We use a mutable queue <span class="machine"><span class="font-tt">run_q</span></span> to hold the scheduler queue. <span class="machine"><span class="font-tt">enqueue</span></span> pushes
tasks into the queue, and <span class="machine"><span class="font-tt">dequeue</span></span> pops tasks from the queue and runs them. We
also have a ref cell <span class="machine"><span class="font-tt">exchanger</span></span> that holds the task offering to exchange a
value.</p><p>The heavy lifting is done by the <span class="machine"><span class="font-tt">spawn</span></span> function. The <span class="machine"><span class="font-tt">spawn</span></span> function runs
the given computation <span class="machine"><span class="font-tt">f</span></span> in an effect handler. If <span class="machine"><span class="font-tt">f</span></span> returns with a value
(case <span class="machine"><span class="font-tt">retc</span></span>), we dequeue and run the next task from the scheduler queue. If
the computation <span class="machine"><span class="font-tt">f</span></span> raises an exception (case <span class="machine"><span class="font-tt">exnc</span></span>), we print the exception
and run the next task from the scheduler.</p><p>The computation <span class="machine"><span class="font-tt">f</span></span> may also perform effects. If <span class="machine"><span class="font-tt">f</span></span> performs the <span class="machine"><span class="font-tt">Yield</span></span>
effect, we enqueue the current task and run the next one from the scheduler
queue. If the effect is <span class="machine"><span class="font-tt">Fork f</span></span>, we enqueue the current task, and recursively
call <span class="machine"><span class="font-tt">spawn</span></span> on <span class="machine"><span class="font-tt">f</span></span>, which run the given task in its own handler effectively
running the task concurrently.</p><p>If the effect is <span class="machine"><span class="font-tt">Xchg</span></span>, then we first check whether there is a task waiting to
exchange. If so, we enqueue the waiting task with the current value being
offered, and immediately resume the current task with the value being offered.
If not, we make the current task the waiting exchanger, and run the next task
from the scheduler queue.</p><p>Now we can write a concurrent program that utilises the newly defined
operations:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> Printf

<span class="ocamlkeyword">let</span> _ = run (<span class="ocamlkeyword">fun</span> _ -&gt;
  fork (<span class="ocamlkeyword">fun</span> _ -&gt;
    printf <span class="ocamlstring">"[t1] Sending 0\n"</span>;
    printf <span class="ocamlstring">"[t1] received %d\n"</span> (xchg 0));
  fork (<span class="ocamlkeyword">fun</span> _ -&gt;
    printf <span class="ocamlstring">"[t2] Sending 1\n"</span>;
    printf <span class="ocamlstring">"[t2] received %d\n"</span> (xchg 1)))</div>



<div class="pre caml-output ok">[t1] Sending 0
[t2] Sending 1
[t2] received 0
[t1] received 1</div></div>

</div><p>Observe that the messages from the two tasks are interleaved. Notice also that
the snippet above makes no reference to the effect handlers, and is in
direct-style (no monadic operations). This example illustrates that, with
effect handlers, the user code in a concurrent program can remain in simple
direct-style, and the use of effect handlers can be fully contained within the
concurrency library implementation.</p>
<h3 class="subsection" id="s:effects-discontinue"><a class="section-anchor" href="#s:effects-discontinue" aria-hidden="true">﻿</a><span class="number">3.1</span> Resuming with an exception</h3>
<p>In addition to resuming a continuation with a value, effect handlers also
permit resuming by raising an effect at the point of perform. This is done with
the help of <span class="machine"><span class="font-tt">discontinue</span></span> primitive. Discontinue helps ensure that
resource-safe code in OCaml behaves correctly.</p><p>For example, consider the dequeue operation in the previous example reproduced
below:</p><div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> dequeue () =
  <span class="ocamlkeyword">if</span> Queue.is_empty run_q <span class="ocamlkeyword">then</span> () <span class="ocamlcomment">(* done *)</span>
  <span class="ocamlkeyword">else</span> (Queue.pop run_q) ()</div></div><p>If the scheduler queue is empty, dequeue considers the scheduler to be complete
and returns to the caller. However, there may still be a pending task waiting
to exchange a value, which remains blocked forever!. If the blocked task holds
onto resources, such resources are leaked. For example, consider the following
task:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> leaky_task () =
  fork (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> oc = open_out <span class="ocamlstring">"secret.txt"</span> <span class="ocamlkeyword">in</span>
    Fun.protect ~finally:(<span class="ocamlkeyword">fun</span> _ -&gt; close_out oc) (<span class="ocamlkeyword">fun</span> _ -&gt;
      output_value oc (xchg 0)))</div></div>

</div><p>The task writes the received message to the file <span class="machine"><span class="font-tt">secret.txt</span></span>. It uses
<span class="machine"><span class="font-tt">Fun.protect</span></span> to ensure that the output channel <span class="machine"><span class="font-tt">oc</span></span> is closed on both normal
and exceptional return cases. If this task does not have a matching exchange,
then the task will remain blocked forever, and leaks the output channel <span class="machine"><span class="font-tt">oc</span></span>.</p><p>We can use <span class="machine"><span class="font-tt">discontinue</span></span> to ensure that the blocked task gets a chance to free
up resources:</p><div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">exception</span> Improper_synchronization

<span class="ocamlkeyword">let</span> dequeue () =
  <span class="ocamlkeyword">if</span> Queue.is_empty run_q <span class="ocamlkeyword">then</span> <span class="ocamlkeyword">begin</span>
    <span class="ocamlkeyword">match</span> !exchanger <span class="ocamlkeyword">with</span>
    | None -&gt; () <span class="ocamlcomment">(* done *)</span>
    | Some (n, k) -&gt;
        exchanger := None;
        discontinue k Improper_synchronization
  <span class="ocamlkeyword">end</span> <span class="ocamlkeyword">else</span> (Queue.pop run_q) ()</div></div><p>When the scheduler queue is empty and there is a blocked exchanger thread, the
dequeue function discontinues the blocked thread with
<span class="machine"><span class="font-tt">Improper_synchronization</span></span> exception. This exception is raised at the blocked
<span class="machine"><span class="font-tt">xchg</span></span> function call, which makes the <span class="machine"><span class="font-tt">finally</span></span> block to be run and close the
output channel <span class="machine"><span class="font-tt">oc</span></span>.</p>
<h2 class="section" id="s:effects-generator"><a class="section-anchor" href="#s:effects-generator" aria-hidden="true">﻿</a><span class="number">4</span> Generators</h2>
<p>Generators are a language mechanism that permits non-continuous traversal of a
data structure. Languages like Python and JavaScript provide primitive support
for generators. Let us see an example of how generators can be implemented
using effect handlers. In particular, we shall implement support for deriving a
generator given an iterator for any data structure. The implementation is given
below:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> MkGen (S :<span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> 'a t
  <span class="ocamlkeyword">val</span> iter : ('a -&gt; unit) -&gt; 'a t -&gt; unit
<span class="ocamlkeyword">end</span>) : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">val</span> gen : 'a S.t -&gt; (unit -&gt; 'a option)
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">let</span> gen : <span class="ocamlkeyword">type</span> a. a S.t -&gt; (unit -&gt; a option) = <span class="ocamlkeyword">fun</span> l -&gt;
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">module</span> M = <span class="ocamlkeyword">struct</span>
      <span class="ocamlkeyword">type</span> _ Effect.t += Yield : a -&gt; unit t
    <span class="ocamlkeyword">end</span> <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> step = <span class="ocamlkeyword">ref</span> (<span class="ocamlkeyword">fun</span> () -&gt;
      match_with (S.iter (<span class="ocamlkeyword">fun</span> v -&gt; perform (M.Yield v))) l
      {retc = (<span class="ocamlkeyword">fun</span> () -&gt; None);
       exnc = raise;
       effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> b) (eff : b Effect.t) -&gt;
         <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
         | M.Yield v -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (b,_) continuation) -&gt;
            step := (<span class="ocamlkeyword">fun</span> () -&gt; continue k ());
            Some v)
         | _ -&gt; None })
    <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">fun</span> () -&gt; !step ()
<span class="ocamlkeyword">end</span></div></div>

</div><p>The type signature for the functor <span class="machine"><span class="font-tt">MkGen</span></span> says that it expects a data
structure of type <span class="machine"><span class="font-tt">'a t</span></span> and its iterator, and it returns a generator function
<span class="machine"><span class="font-tt">gen</span></span>. When the <span class="machine"><span class="font-tt">gen</span></span> function is applied to the data structure, it returns a
thunk. Everytime this thunk is invoked, the program performs one step of the
traversal on the data structure.</p><p>The implementation utilises several advanced features of OCaml including local
modules, recursive values and locally abstract types. This illustrates that
effect handlers work well with other advanced features in the language. While
the implementation is complicated, the crux of the idea is that, at every step
of the iteration, the <span class="machine"><span class="font-tt">Yield</span></span> effect is performed. This effect is handled by a
local handler (case <span class="machine"><span class="font-tt">effc</span></span>), that prepares a <span class="machine"><span class="font-tt">step</span></span> function in order to
continue the traversal. When the traversal is complete (case <span class="machine"><span class="font-tt">retc</span></span>), <span class="machine"><span class="font-tt">None</span></span> is
returned to the caller to indicate the end of traversal.</p><p>We can now traverse data structures on demand given only their iterator. For
example, we can do on-demand traversal of lists as follows:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> L = MkGen (<span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> 'a t = 'a list
  <span class="ocamlkeyword">let</span> iter = List.iter
<span class="ocamlkeyword">end</span>)

<span class="ocamlkeyword">let</span> next = L.gen [1;2;3]</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> next();;</div>



<div class="pre caml-output ok">- : int option = Some 1</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> next();;</div>



<div class="pre caml-output ok">- : int option = Some 2</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> next();;</div>



<div class="pre caml-output ok">- : int option = Some 3</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> next();;</div>



<div class="pre caml-output ok">- : int option = None</div></div>

</div><p>We can use the same <span class="machine"><span class="font-tt">MkGen</span></span> functor on other data types too. For example,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> A = MkGen (<span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> 'a t = 'a array
  <span class="ocamlkeyword">let</span> iter = Array.iter
<span class="ocamlkeyword">end</span>)
<span class="ocamlkeyword">let</span> next = A.gen [|1;2;3|]</div></div>

</div><div class="caml-example toplevel">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> next();;</div>



<div class="pre caml-output ok">- : int option = Some 1</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> next();;</div>



<div class="pre caml-output ok">- : int option = Some 2</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> next();;</div>



<div class="pre caml-output ok">- : int option = Some 3</div></div>
<div class="ocaml">



<div class="pre caml-input"><span class="ocamlprompt">#</span> next();;</div>



<div class="pre caml-output ok">- : int option = None</div></div>

</div>
<h2 class="section" id="s:effects-semantics"><a class="section-anchor" href="#s:effects-semantics" aria-hidden="true">﻿</a><span class="number">5</span> Semantics</h2>
<p>In this section, we shall see the semantics of the effect handlers with the
help of examples.</p>
<h3 class="subsection" id="s:effects-nesting"><a class="section-anchor" href="#s:effects-nesting" aria-hidden="true">﻿</a><span class="number">5.1</span> Nesting handlers</h3>
<p>Similar to exception handlers, the effect handlers can be nested.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">type</span> _ Effect.t += E : int t
                 | F : string t

<span class="ocamlkeyword">let</span> foo () = perform F

<span class="ocamlkeyword">let</span> bar () =
  try_with foo ()
  { effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff: a t) -&gt;
      <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
      | E -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (a,_) continuation) -&gt;
          failwith <span class="ocamlstring">"impossible"</span>)
      | _ -&gt; None }

<span class="ocamlkeyword">let</span> baz () =
  try_with bar ()
  { effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff: a t) -&gt;
      <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
      | F -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (a,_) continuation) -&gt;
          continue k <span class="ocamlstring">"Hello, world!"</span>)
      | _ -&gt; None }</div></div>

</div><p>In this example, the computation <span class="machine"><span class="font-tt">foo</span></span> performs <span class="machine"><span class="font-tt">F</span></span>, the inner handler only
handles <span class="machine"><span class="font-tt">E</span></span> and the outer handler handles <span class="machine"><span class="font-tt">F</span></span>. The call to <span class="machine"><span class="font-tt">baz</span></span> returns
<span class="machine"><span class="font-tt">Hello, world!</span></span>.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">baz ()</div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"Hello, world!"</span></div></div>

</div>
<h3 class="subsection" id="s:effects-fibers"><a class="section-anchor" href="#s:effects-fibers" aria-hidden="true">﻿</a><span class="number">5.2</span> Fibers</h3>
<p>It is useful to know a little bit about the implementation of effect handlers
to appreciate the design choices and their performance characteristics. Effect
handlers are implemented with the help of runtime-managed, dynamically growing
segments of stack called <span class="font-it">fibers</span>. The program stack in OCaml is a
linked-list of such fibers.</p><p>A new fiber is allocated for evaluating the computation enclosed by an effect
handler. The fiber is freed when the computation returns to the caller either
normally by returning a value or by raising an exception.</p><p>At the point of <span class="machine"><span class="font-tt">perform</span></span> in <span class="machine"><span class="font-tt">foo</span></span> in the previous example, the program stack
looks like this:</p><div class="ocaml">



<div class="pre caml-input">+-----+   +-----+   +-----+
|     |   |     |   |     |
| baz |&lt;--| bar |&lt;--| foo |
|     |   |     |   |     |
|     |   |     |   |     |
+-----+   +-----+   +-----+ &lt;- stack_pointer</div></div><p>The two links correspond to the two effect handlers in the program. When the
effect <span class="machine"><span class="font-tt">F</span></span> is handled in <span class="machine"><span class="font-tt">baz</span></span>, the program state looks as follows:</p><div class="ocaml">



<div class="pre caml-input">+-----+                   +-----+   +-----+
|     |                   |     |   |     |   +-+
| baz |                   | bar |&lt;--| foo |&lt;--|k|
|     |                   |     |   |     |   +-+
+-----+ &lt;- stack_pointer  +-----+   +-----+</div></div><p>The delimited continuation <span class="machine"><span class="font-tt">k</span></span> is an object on the heap that refers to the
segment of the stack that corresponds to the suspended computation. Capturing a
continuation does not involve copying stack frames. When the continuation is
resumed, the stack is restored to the previous state by linking together the
segment pointed to by <span class="machine"><span class="font-tt">k</span></span> to the current stack. Since neither continuation
capture nor resumption requires copying stack frames, suspending the execution
using <span class="machine"><span class="font-tt">perform</span></span> and resuming it using either <span class="machine"><span class="font-tt">continue</span></span> or <span class="machine"><span class="font-tt">discontinue</span></span> are
fast.</p>
<h3 class="subsection" id="s:effects-unhandled"><a class="section-anchor" href="#s:effects-unhandled" aria-hidden="true">﻿</a><span class="number">5.3</span> Unhandled effects</h3>
<p>Unlike languages such as Eff and Koka, effect handlers in OCaml do not provide
<span class="font-it">effect safety</span>; the compiler does not statically ensure that all the
effects performed by the program is handled. If effects do not have a matching
handler, then <span class="machine"><span class="font-tt">Unhandled</span></span> exception is raised at the point of the corresponding
<span class="machine"><span class="font-tt">perform</span></span>. For example, in the previous example, <span class="machine"><span class="font-tt">bar</span></span> does not handle the
effect <span class="machine"><span class="font-tt">F</span></span>. Hence, we will get <span class="machine"><span class="font-tt">Unhandled</span></span> exception when we run <span class="machine"><span class="font-tt">bar</span></span>.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">try</span> bar () <span class="ocamlkeyword">with</span> Unhandled -&gt; <span class="ocamlstring">"Saw unhandled exception"</span></div>



<div class="pre caml-output ok">- : string = <span class="ocamlstring">"Saw unhandled exception"</span></div></div>

</div>
<h3 class="subsection" id="s:effects-linearity"><a class="section-anchor" href="#s:effects-linearity" aria-hidden="true">﻿</a><span class="number">5.4</span> Linear continuations</h3>
<p>The delimited continuations in OCaml must be used linearly – every captured
continuation must be resumed either with a <span class="machine"><span class="font-tt">continue</span></span> or <span class="machine"><span class="font-tt">discontinue</span></span> exactly
once. Attempting to use a continuation more than once raises
<span class="machine"><span class="font-tt">Continuation_already_taken</span></span> exception. For example:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">try_with perform (Xchg 0)
{ effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> a) (eff : a t) -&gt;
    <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
    | Xchg n -&gt; Some (<span class="ocamlkeyword">fun</span> (k: (a, _) continuation) -&gt;
        continue k 21 + continue k 21)
    | _ -&gt; None }</div>



<div class="pre caml-output ok">Exception: Continuation_already_taken.</div></div>

</div><p>The primary motivation for adding effect handlers to OCaml is to enable
concurrent programming. One-shot continuations are sufficient for almost all of
the concurrent programming use cases. They are also much cheaper to implement
compared to multi-shot continuations since they do not require stack frames to
be copied. Moreover, OCaml programs may also manipulate linear resources such
as sockets and file descriptors. The linearity discipline is easily broken if
the continuations are allowed to resume more than once. It would be quite hard
to debug such linearity violations on resources due to the lack of static
checks for linearity and the non-local nature of control flow. Hence, OCaml
does not support multi-shot continuations.</p><p>While the “at-most once resumption” property on continuations is ensured with
a dynamic check, there is no check to ensure that the continuations are resumed
“at least once”. It is left to the user to ensure that the captured
continuations are resumed at least once. Not resuming continuations will leak
the memory allocated for the fibers and also any resources that the suspended
computation may hold.</p><p>One may install a finaliser on the captured continuation to ensure that the
resources are freed:</p><div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">exception</span> Unwind
Gc.finalise (<span class="ocamlkeyword">fun</span> k -&gt;
  <span class="ocamlkeyword">try</span> ignore (discontinue k Unwind) <span class="ocamlkeyword">with</span> _ -&gt; ()) k</div></div><p>In this case, if <span class="machine"><span class="font-tt">k</span></span> is never resumed, then the finaliser ensures that the
continuation stack is unwound by discontinuing with <span class="machine"><span class="font-tt">Unwind</span></span> exception,
allowing the computation to free up resources. However, the runtime cost of
finalisers is much more than the cost of capturing a continuation. Hence, it is
recommended that the user takes care of resuming the continuation exactly once
rather than relying on the finaliser.</p>
<h2 class="section" id="s:effects-shallow"><a class="section-anchor" href="#s:effects-shallow" aria-hidden="true">﻿</a><span class="number">6</span> Shallow handlers</h2>
<p>The examples that we have seen so far have used <span class="font-it">deep</span> handlers.
Whenever a continuation is captured in a deep handler, the captured
continuation also includes the handler. OCaml also provides <span class="font-it">shallow</span>
handlers. Compared to deep handlers, a shallow handler does not include the
captured continuation, and expects the user to provide a handler when the
continuation is resumed.</p><p>Shallow handlers make it easier to express certain kinds of programs. For
example, suppose we want to implement state handler that permits put and get
operations on ambient state. We can implement the state handler using deep
handlers as follows:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> Effect
<span class="ocamlkeyword">open</span> Effect.Deep

<span class="ocamlkeyword">type</span> _ Effect.t += Put : int -&gt; unit Effect.t
                 | Get : int Effect.t
<span class="ocamlkeyword">let</span> put v = perform (Put v)
<span class="ocamlkeyword">let</span> get () = perform Get

<span class="ocamlkeyword">let</span> run (f : unit -&gt; unit) ~init =
  <span class="ocamlkeyword">let</span> comp =
    match_with f ()
    { retc = (<span class="ocamlkeyword">fun</span> x -&gt; (<span class="ocamlkeyword">fun</span> s -&gt; (s, x)));
      exnc = raise;
      effc = <span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> b) (e : b Effect.t) -&gt;
        <span class="ocamlkeyword">match</span> e <span class="ocamlkeyword">with</span>
        | Get -&gt; Some (<span class="ocamlkeyword">fun</span> (k : (b, int -&gt; (int * unit)) continuation) -&gt;
            (<span class="ocamlkeyword">fun</span> (s : int) -&gt; continue k s s))
        | Put s' -&gt; Some (<span class="ocamlkeyword">fun</span> k -&gt;
            (<span class="ocamlkeyword">fun</span> _s -&gt; continue k () s'))
        | _ -&gt; None }
  <span class="ocamlkeyword">in</span>
  comp init</div></div>

</div><p>The <span class="machine"><span class="font-tt">get</span></span> operation returns the current state, and <span class="machine"><span class="font-tt">put</span></span> updates the state. For
simplicity, we assume that the state is an integer. This implementation is
analogous to the monadic implementation of state. The <span class="machine"><span class="font-tt">run</span></span> function builds up
a new closure when it handles <span class="machine"><span class="font-tt">Get</span></span> and <span class="machine"><span class="font-tt">Put</span></span> effects. Here is an example of
using this state handler:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> foo () : unit =
  printf <span class="ocamlstring">"%d\n"</span> (get ());
  put 42;
  printf <span class="ocamlstring">"%d\n"</span> (get ());
  put 21;
  printf <span class="ocamlstring">"%d\n"</span> (get ())</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">run foo ~init:0</div>



<div class="pre caml-output ok">0
42
21
- : int * unit = (21, ())</div></div>

</div><p>The shallow handler version of state handler is given below:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">open</span> Effect.Shallow

<span class="ocamlkeyword">let</span> run (f: unit -&gt; unit) ~init =
  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> loop : <span class="ocamlkeyword">type</span> a. int -&gt; (a, unit) continuation -&gt; a -&gt; int * unit =
    <span class="ocamlkeyword">fun</span> s k x -&gt;
      continue_with k x
      { retc = (<span class="ocamlkeyword">fun</span> x -&gt; (s,x));
        exnc = (<span class="ocamlkeyword">fun</span> e -&gt; raise e);
        effc = (<span class="ocamlkeyword">fun</span> (<span class="ocamlkeyword">type</span> b) (eff : b t) -&gt;
          <span class="ocamlkeyword">match</span> eff <span class="ocamlkeyword">with</span>
          | Get -&gt; Some (<span class="ocamlkeyword">fun</span> (k : (b,_) continuation) -&gt;
              loop s k s)
          | Put s' -&gt; Some (<span class="ocamlkeyword">fun</span> (k : (b,_) continuation) -&gt;
              loop s' k ())
          | e -&gt; None) }
  <span class="ocamlkeyword">in</span>
  loop init (fiber f) ()</div></div>

</div><p>The shallow handlers use a different set of primitives compared to the deep
handlers. The primitive <span class="machine"><span class="font-tt">fiber</span></span> takes an <span class="machine"><span class="font-tt">'a -&gt; 'b</span></span> function and returns a
<span class="machine"><span class="font-tt">('a,'b) continuation</span></span>. <span class="machine"><span class="font-tt">continue_with k v h</span></span> resumes the continuation <span class="machine"><span class="font-tt">k</span></span> with
value <span class="machine"><span class="font-tt">v</span></span> under the handler <span class="machine"><span class="font-tt">h</span></span>. Observe that unlike deep handlers, we avoid
allocating a new closure when handling <span class="machine"><span class="font-tt">Get</span></span> and <span class="machine"><span class="font-tt">Put</span></span> effects. The ambient
state <span class="machine"><span class="font-tt">s</span></span> is simply threaded through in the recursive call. The use of the
shallow state handler remains the same as the deep version:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> foo () : unit =
  printf <span class="ocamlstring">"%d\n"</span> (get ());
  put 42;
  printf <span class="ocamlstring">"%d\n"</span> (get ());
  put 21;
  printf <span class="ocamlstring">"%d\n"</span> (get ())</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">run foo ~init:0</div>



<div class="pre caml-output ok">0
42
21
- : int * unit = (21, ())</div></div>

</div>
<hr>
<div class="bottom-navigation"><a class="previous" href="advexamples.html">« Advanced examples with classes and modules</a><a class="next" href="language.html">The OCaml language »</a></div>




<div class="copyright">Copyright © 2022 Institut National de
Recherche en Informatique et en Automatique</div></div></body></html>