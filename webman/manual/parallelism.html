<!DOCTYPE html><html lang="en"><head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.35">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>OCaml - Parallel programming</title>
<script src="scroll.js"></script><script src="navigation.js"></script><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></head>
<body><div class="content manual"><div id="sidebar-button"><span>☰</span></div><nav id="part-title"><span>☰</span>An introduction to OCaml</nav><ul id="part-menu"><li><a href="coreexamples.html">The core language</a></li><li><a href="moduleexamples.html">The module system</a></li><li><a href="objectexamples.html">Objects in OCaml</a></li><li><a href="lablexamples.html">Labeled arguments</a></li><li><a href="polyvariant.html">Polymorphic variants</a></li><li><a href="polymorphism.html">Polymorphism and its limitations</a></li><li><a href="gadts-tutorial.html">Generalized algebraic datatypes</a></li><li><a href="advexamples.html">Advanced examples with classes and modules</a></li><li class="active"><a href="parallelism.html">Parallel programming</a></li></ul>




<h1 class="chapter" id="sec79"><span class="chapter-number">Chapter 9</span> Parallel programming</h1>
<header id="sidebar"><nav class="toc brand"><a class="brand" href="https://ocaml.org/"><img src="colour-logo.svg" class="svg" alt="OCaml"></a></nav><nav class="toc"><div class="toc_version"><a id="version-select" href="https://ocaml.org/releases/">Version 5.0</a></div><div class="toc_title"><a href="index.html">&lt; The OCaml Manual</a></div><ul><li class="top"><a href="#">Parallel programming</a></li>
<li><a href="parallelism.html#s%3Adomains"><span class="number">1</span> Domains</a>
</li><li><a href="parallelism.html#s%3Aparfib"><span class="number">2</span> Domainslib: A library for nested-parallel programming</a>
</li><li><a href="parallelism.html#s%3Agc"><span class="number">3</span> Parallel garbage collection</a>
</li><li><a href="parallelism.html#s%3Amm_easy"><span class="number">4</span> Memory model: The easy bits</a>
</li><li><a href="parallelism.html#s%3Aatomics"><span class="number">5</span> Atomics</a>
</li><li><a href="parallelism.html#s%3Async"><span class="number">6</span> Blocking synchronization</a>
</li></ul></nav></header>
<p>
<a id="c:parallelism"></a></p><p>In this chapter, we shall look at the parallel programming facilities in OCaml.
The OCaml standard library exposes low-level primitives for parallel
programming. We recommend the users to utilise higher-level parallel
programming libraries such as
<a href="https://github.com/ocaml-multicore/domainslib">domainslib</a>. This
tutorial will first cover the high-level parallel programming using domainslib
followed by low-level primitives exposed by the compiler. This tutorial will
first cover the parallelism facilities provided by the standard library
followed by high-level parallel programming using domainslib.</p><p>OCaml distinguishes concurrency and parallelism and provides distinct
mechanisms for expressing them. Concurrency is overlapped execution of tasks
whereas parallelism is simultaneous execution of tasks. In particular, parallel
tasks overlap in time but concurrent tasks may not. Tasks may execute
concurrently by yielding control to each other. While concurrency is a program
structuring mechanism, parallelism is a mechanism to make your programs run
faster. If you are interested in the concurrent programming mechanisms in
OCaml, please refer to the section <a href="effects.html#s%3Aeffect-handlers">11.24</a> on effect handlers.</p>
<h2 class="section" id="s:domains"><a class="section-anchor" href="#s:domains" aria-hidden="true"></a><span class="number">1</span> Domains</h2>
<p>Domains are the units of parallelism in OCaml. The module <a href="../api/Domain.html"><span class="font-tt">Domain</span></a>
provides the primitives to create and manage domains. New domains can be
spawned using the <span class="machine"><span class="font-tt">spawn</span></span> function.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input">Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; print_endline <span class="ocamlstring">"I ran in parallel"</span>)</div>



<div class="pre caml-output ok">I ran <span class="ocamlkeyword">in</span> parallel
- : unit Domain.t = &lt;abstr&gt;</div></div>

</div><p>The <span class="machine"><span class="font-tt">spawn</span></span> function executes the given computation in parallel with
the calling domain.</p><p>Domains are heavy-weight entities. Each domain maps 1:1 to an operating system
thread. Each domain also has its own runtime state, which includes domain-local
structures for allocating memory. Hence, they are relatively expensive to
create and tear down.</p><p><em><span class="font-bold">It is recommended that the users spawn exactly one domain per
available core.</span></em>.</p><p>In this tutorial, we shall be implementing, running and measuring the
performance of parallel programs. The results observed are dependent on the
number of cores available on the target machine. This tutorial is being written
on a 2.3 GHz Quad-Core Intel Core i7 MacBook Pro with 4 cores and 8 hardware
threads. It is reasonable to expect roughly 4x performance on 4 domains for
parallel programs with little coordination between the domains, and when the
machine is not under load. Beyond 4 domains, the speedup is likely to be less
than linear. We shall also use the command-line benchmarking tool
<a href="https://github.com/sharkdp/hyperfine">hyperfine</a> for benchmarking our
programs.</p>
<h3 class="subsection" id="s:join"><a class="section-anchor" href="#s:join" aria-hidden="true">﻿</a><span class="number">1.1</span> Joining domains</h3>
<p>We shall use the recursive program to compute the nth Fibonacci number as a
running example. The sequential program for computing the nth Fibonacci number
is given below.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* fib.ml *)</span>
<span class="ocamlkeyword">let</span> n = <span class="ocamlkeyword">try</span> int_of_string Sys.argv.(1) <span class="ocamlkeyword">with</span> _ -&gt; 1

<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> fib n = <span class="ocamlkeyword">if</span> n &lt; 2 <span class="ocamlkeyword">then</span> 1 <span class="ocamlkeyword">else</span> fib (n - 1) + fib (n - 2)

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> r = fib n <span class="ocamlkeyword">in</span>
  Printf.printf <span class="ocamlstring">"fib(%d) = %d\n%!"</span> n r

<span class="ocamlkeyword">let</span> _ = main ()</div></div>

</div><p>The program can be compiled and benchmarked as follows.</p><pre>$ ocamlopt -o fib.exe fib.ml
$ ./fib.exe 42
fib(42) = 433494437
$ hyperfine './fib.exe 42' # Benchmarking
Benchmark 1: ./fib.exe 42
  Time (mean ± sd):     1.193 s ±  0.006 s    [User: 1.186 s, System: 0.003 s]
  Range (min … max):    1.181 s …  1.202 s    10 runs
</pre><p>
We see that it takes around 1.2 seconds to compute the nth Fibonacci number.</p><p>Spawned domains can be joined using the <span class="machine"><span class="font-tt">join</span></span> function to get their results.
The following program computes the nth Fibonacci number twice in parallel.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* fib_twice.ml *)</span>
<span class="ocamlkeyword">let</span> n = <span class="ocamlkeyword">try</span> int_of_string Sys.argv.(1) <span class="ocamlkeyword">with</span> _ -&gt; 1

<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> fib n = <span class="ocamlkeyword">if</span> n &lt; 2 <span class="ocamlkeyword">then</span> 1 <span class="ocamlkeyword">else</span> fib (n - 1) + fib (n - 2)

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> d1 = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; fib n) <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> d2 = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; fib n) <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r1 = Domain.join d1 <span class="ocamlkeyword">in</span>
  Printf.printf <span class="ocamlstring">"fib(%d) = %d\n%!"</span> n r1;
  <span class="ocamlkeyword">let</span> r2 = Domain.join d2 <span class="ocamlkeyword">in</span>
  Printf.printf <span class="ocamlstring">"fib(%d) = %d\n%!"</span> n r2

<span class="ocamlkeyword">let</span> _ = main ()</div></div>

</div><p>The program spawns two domains which compute the nth Fibonacci number. The
<span class="machine"><span class="font-tt">spawn</span></span> function returns a <span class="machine"><span class="font-tt">Domain.t</span></span> value which can be joined to get the
result of the parallel computation. The <span class="machine"><span class="font-tt">join</span></span> function blocks until the
computation runs to completion.</p><pre>$ ocamlopt -o fib_twice.exe fib_twice.ml
$ ./fib_twice.exe
fib(42) = 433494437
fib(42) = 433494437
$ hyperfine './fib_twice.exe 42'
Benchmark 1: ./fib_twice.exe 42
  Time (mean ± sd):     1.249 s ±  0.025 s    [User: 2.451 s, System: 0.012 s]
  Range (min … max):    1.221 s …  1.290 s    10 runs
</pre><p>
As one can see that computing the nth Fibonacci number twice almost took the
same time as computing it once thanks to parallelism.</p>
<h2 class="section" id="s:parfib"><a class="section-anchor" href="#s:parfib" aria-hidden="true">﻿</a><span class="number">2</span> Domainslib: A library for nested-parallel programming</h2>
<p>Let us attempt to parallelise the Fibonacci function. The two recursive calls
may be executed in parallel. However, naively parallelising the recursive calls
by spawning domains for each one will not work as it spawns too many domains.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* fib_par1.ml *)</span>
<span class="ocamlkeyword">let</span> n = <span class="ocamlkeyword">try</span> int_of_string Sys.argv.(1) <span class="ocamlkeyword">with</span> _ -&gt; 1

<span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> fib n =
  <span class="ocamlkeyword">if</span> n &lt; 2 <span class="ocamlkeyword">then</span> 1 <span class="ocamlkeyword">else</span> <span class="ocamlkeyword">begin</span>
    <span class="ocamlkeyword">let</span> d1 = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; fib (n - 1)) <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> d2 = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt; fib (n - 2)) <span class="ocamlkeyword">in</span>
    Domain.join d1 + Domain.join d2
  <span class="ocamlkeyword">end</span>

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> r = fib n <span class="ocamlkeyword">in</span>
  Printf.printf <span class="ocamlstring">"fib(%d) = %d\n%!"</span> n r

<span class="ocamlkeyword">let</span> _ = main ()</div>



<div class="pre caml-output ok">fib(1) = 1
<span class="ocamlkeyword">val</span> n : int = 1
<span class="ocamlkeyword">val</span> fib : int -&gt; int = &lt;<span class="ocamlkeyword">fun</span>&gt;
<span class="ocamlkeyword">val</span> main : unit -&gt; unit = &lt;<span class="ocamlkeyword">fun</span>&gt;</div></div>

</div><pre>$ ocamlopt -o fib_par1.exe fib_par1.ml
$ ./fib_par1.exe 42
Fatal error: exception Failure("failed to allocate domain")
</pre><p>
OCaml has a limit of 128 domains that can be active at the same time. Attempt
to spawn more domains will raise an exception. How then can we parallelise the
Fibonacci function?</p>
<h3 class="subsection" id="s:parfib_domainslib"><a class="section-anchor" href="#s:parfib_domainslib" aria-hidden="true">﻿</a><span class="number">2.1</span> Parallelising Fibonacci using domainslib</h3>
<p>The OCaml standard library only provides low-level primitives for concurrent
and parallel programming, leaving high-level programming libraries to be
developed and distributed outside the core compiler distribution.
<a href="https://github.com/ocaml-multicore/domainslib">Domainslib</a> is such a
library for nested-parallel programming, which is epitomized by the parallelism
available in the recursive Fibonacci computation. Let us use domainslib to
parallelise the recursive Fibonacci program. It is recommended that you install
domainslib using the <a href="https://opam.ocaml.org/">opam</a> package manager. This
tutorial uses domainlib version 0.4.2.</p><p>Domainslib provides an async/await mechanism for spawning parallel tasks and
waiting on their results. On top of this mechanism, domainslib provides
parallel iterators. At its core, domainslib has an efficient implementation of
work-stealing queue in order to efficiently share tasks with other domains.
Parallel implementation of the Fibonacci program is given below.</p><pre>(* fib_par2.ml *)
let num_domains = try int_of_string Sys.argv.(1) with _ -&gt; 1
let n = try int_of_string Sys.argv.(2) with _ -&gt; 1

let rec fib n = if n &lt; 2 then 1 else fib (n - 1) + fib (n - 2)

module T = Domainslib.Task

let rec fib_par pool n =
  if n &gt; 20 then begin
    let a = T.async pool (fun _ -&gt; fib_par pool (n-1)) in
    let b = T.async pool (fun _ -&gt; fib_par pool (n-2)) in
    T.await pool a + T.await pool b
  end else fib n

let main () =
  let pool = T.setup_pool ~num_additional_domains:(num_domains - 1) () in
  let res = T.run pool (fun _ -&gt; fib_par pool n) in
  T.teardown_pool pool;
  Printf.printf "fib(%d) = %d\n" n res

let _ = main ()
</pre><p>
The program takes the number of domains and the input to the Fibonacci function
as the first and the second command-line arguments respectively.</p><p>Let’s start with the main function. First, we set up a pool of domains on which
the nested parallel tasks will run. The domain invoking the <span class="machine"><span class="font-tt">run</span></span> function will
also participate in executing the tasks submitted to the pool. We invoke the
parallel Fibonacci function <span class="machine"><span class="font-tt">fib_par</span></span> in the <span class="machine"><span class="font-tt">run</span></span> function. Finally, we
teardown the pool and print the result.</p><p>For sufficiently large inputs (<span class="machine"><span class="font-tt">n &gt; 20</span></span>), the <span class="machine"><span class="font-tt">fib_par</span></span> function spawns the
left and the right recursive calls asynchronously in the pool using the <span class="machine"><span class="font-tt">async</span></span>
function. The <span class="machine"><span class="font-tt">async</span></span> function returns a promise for the result. The result of
an asynchronous computation is obtained by awaiting on the promise using the
<span class="machine"><span class="font-tt">await</span></span> function. The <span class="machine"><span class="font-tt">await</span></span> function call blocks until the promise is
resolved.</p><p>For small inputs, the <span class="machine"><span class="font-tt">fib_par</span></span> function simply calls the sequential Fibonacci
function <span class="machine"><span class="font-tt">fib</span></span>. It is important to switch to sequential mode for small problem
sizes. If not, the cost of parallelisation will outweigh the work available.</p><p>For simplicity, we use <span class="machine"><span class="font-tt">ocamlfind</span></span> to compile this program. It is recommended
that the users use <a href="https://github.com/ocaml/dune">dune</a> to build their
programs that utilise libraries installed through
<a href="https://opam.ocaml.org/">opam</a>.</p><pre>$ ocamlfind ocamlopt -package domainslib -linkpkg -o fib_par2.exe fib_par2.ml
$ ./fib_par2.exe 1 42
fib(42) = 433494437
$ hyperfine './fib.exe 42' './fib_par2.exe 2 42' \
            './fib_par2.exe 4 42' './fib_par2.exe 8 42'
Benchmark 1: ./fib.exe 42
  Time (mean ± sd):     1.217 s ±  0.018 s    [User: 1.203 s, System: 0.004 s]
  Range (min … max):    1.202 s …  1.261 s    10 runs

Benchmark 2: ./fib_par2.exe 2 42
  Time (mean ± sd):    628.2 ms ±   2.9 ms    [User: 1243.1 ms, System: 4.9 ms]
  Range (min … max):   625.7 ms … 634.5 ms    10 runs

Benchmark 3: ./fib_par2.exe 4 42
  Time (mean ± sd):    337.6 ms ±  23.4 ms    [User: 1321.8 ms, System: 8.4 ms]
  Range (min … max):   318.5 ms … 377.6 ms    10 runs

Benchmark 4: ./fib_par2.exe 8 42
  Time (mean ± sd):    250.0 ms ±   9.4 ms    [User: 1877.1 ms, System: 12.6 ms]
  Range (min … max):   242.5 ms … 277.3 ms    11 runs

Summary
  './fib_par2.exe 8 42' ran
    1.35 ± 0.11 times faster than './fib_par2.exe 4 42'
    2.51 ± 0.10 times faster than './fib_par2.exe 2 42'
    4.87 ± 0.20 times faster than './fib.exe 42'
</pre><p>
The results show that, with 8 domains, the parallel Fibonacci program runs 4.87
times faster than the sequential version.</p>
<h3 class="subsection" id="s:par_iterators"><a class="section-anchor" href="#s:par_iterators" aria-hidden="true">﻿</a><span class="number">2.2</span> Parallel iterators</h3>
<p>Many numerical algorithms use for-loops. The parallel-for primitive provides a
straight-forward way to parallelize such code. Lets take the
<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/spectralnorm.html#spectralnorm">spectral-norm</a>
benchmark from the computer language benchmarks game and parallelise it. The
sequential version of the program is given below.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* spectralnorm.ml *)</span>
<span class="ocamlkeyword">let</span> n = <span class="ocamlkeyword">try</span> int_of_string Sys.argv.(1) <span class="ocamlkeyword">with</span> _ -&gt; 32

<span class="ocamlkeyword">let</span> eval_A i j = 1. /. float((i+j)*(i+j+1)/2+i+1)

<span class="ocamlkeyword">let</span> eval_A_times_u u v =
  <span class="ocamlkeyword">let</span> n = Array.length v - 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">for</span> i = 0 <span class="ocamlkeyword">to</span>  n <span class="ocamlkeyword">do</span>
    <span class="ocamlkeyword">let</span> vi = <span class="ocamlkeyword">ref</span> 0. <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">for</span> j = 0 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span> vi := !vi +. eval_A i j *. u.(j) <span class="ocamlkeyword">done</span>;
    v.(i) &lt;- !vi
  <span class="ocamlkeyword">done</span>

<span class="ocamlkeyword">let</span> eval_At_times_u u v =
  <span class="ocamlkeyword">let</span> n = Array.length v - 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">for</span> i = 0 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span>
    <span class="ocamlkeyword">let</span> vi = <span class="ocamlkeyword">ref</span> 0. <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">for</span> j = 0 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span> vi := !vi +. eval_A j i *. u.(j) <span class="ocamlkeyword">done</span>;
    v.(i) &lt;- !vi
  <span class="ocamlkeyword">done</span>

<span class="ocamlkeyword">let</span> eval_AtA_times_u u v =
  <span class="ocamlkeyword">let</span> w = Array.make (Array.length u) 0.0 <span class="ocamlkeyword">in</span>
  eval_A_times_u u w; eval_At_times_u w v

<span class="ocamlkeyword">let</span> () =
  <span class="ocamlkeyword">let</span> u = Array.make n 1.0  <span class="ocamlkeyword">and</span>  v = Array.make n 0.0 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">for</span> _i = 0 <span class="ocamlkeyword">to</span> 9 <span class="ocamlkeyword">do</span>
    eval_AtA_times_u u v; eval_AtA_times_u v u
  <span class="ocamlkeyword">done</span>;

  <span class="ocamlkeyword">let</span> vv = <span class="ocamlkeyword">ref</span> 0.0  <span class="ocamlkeyword">and</span>  vBv = <span class="ocamlkeyword">ref</span> 0.0 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">for</span> i=0 <span class="ocamlkeyword">to</span> n-1 <span class="ocamlkeyword">do</span>
    vv := !vv +. v.(i) *. v.(i);
    vBv := !vBv +. u.(i) *. v.(i)
  <span class="ocamlkeyword">done</span>;
  Printf.printf <span class="ocamlstring">"%0.9f\n"</span> (sqrt(!vBv /. !vv))</div></div>

</div><p>Observe that the program has nested loops in <span class="machine"><span class="font-tt">eval_A_times_u</span></span> and
<span class="machine"><span class="font-tt">eval_At_times_u</span></span>. Each iteration of the outer loop body reads from <span class="machine"><span class="font-tt">u</span></span> but
writes to disjoint memory locations in <span class="machine"><span class="font-tt">v</span></span>. Hence, the iterations of the outer
loop are not dependent on each other and can be executed in parallel.</p><p>The parallel version of spectral norm is shown below.</p><pre>(* spectralnorm_par.ml *)
let num_domains = try int_of_string Sys.argv.(1) with _ -&gt; 1
let n = try int_of_string Sys.argv.(2) with _ -&gt; 32

let eval_A i j = 1. /. float((i+j)*(i+j+1)/2+i+1)

module T = Domainslib.Task

let eval_A_times_u pool u v =
  let n = Array.length v - 1 in
  T.parallel_for pool ~start:0 ~finish:n ~body:(fun i -&gt;
    let vi = ref 0. in
    for j = 0 to n do vi := !vi +. eval_A i j *. u.(j) done;
    v.(i) &lt;- !vi
  )

let eval_At_times_u pool u v =
  let n = Array.length v - 1 in
  T.parallel_for pool ~start:0 ~finish:n ~body:(fun i -&gt;
    let vi = ref 0. in
    for j = 0 to n do vi := !vi +. eval_A j i *. u.(j) done;
    v.(i) &lt;- !vi
  )

let eval_AtA_times_u pool u v =
  let w = Array.make (Array.length u) 0.0 in
  eval_A_times_u pool u w; eval_At_times_u pool w v

let () =
  let pool = T.setup_pool ~num_additional_domains:(num_domains - 1) () in
  let u = Array.make n 1.0  and  v = Array.make n 0.0 in
  T.run pool (fun _ -&gt;
  for _i = 0 to 9 do
    eval_AtA_times_u pool u v; eval_AtA_times_u pool v u
  done);

  let vv = ref 0.0  and  vBv = ref 0.0 in
  for i=0 to n-1 do
    vv := !vv +. v.(i) *. v.(i);
    vBv := !vBv +. u.(i) *. v.(i)
  done;
  T.teardown_pool pool;
  Printf.printf "%0.9f\n" (sqrt(!vBv /. !vv))
</pre><p>
Observe that the <span class="machine"><span class="font-tt">parallel_for</span></span> function is isomorphic to the for-loop in the
sequential version. No other change is required except for the boiler plate
code to setup and teardown the pools.</p><pre>$ ocamlopt -o spectralnorm.exe spectralnorm.ml
$ ocamlfind ocamlopt -package domainslib -linkpkg -o spectralnorm_par.exe \
  spectralnorm_par.ml
$ hyperfine './spectralnorm.exe 4096' './spectralnorm_par.exe 2 4096' \
            './spectralnorm_par.exe 4 4096' './spectralnorm_par.exe 8 4096'
Benchmark 1: ./spectralnorm.exe 4096
  Time (mean ± sd):     1.989 s ±  0.013 s    [User: 1.972 s, System: 0.007 s]
  Range (min … max):    1.975 s …  2.018 s    10 runs

Benchmark 2: ./spectralnorm_par.exe 2 4096
  Time (mean ± sd):     1.083 s ±  0.015 s    [User: 2.140 s, System: 0.009 s]
  Range (min … max):    1.064 s …  1.102 s    10 runs

Benchmark 3: ./spectralnorm_par.exe 4 4096
  Time (mean ± sd):    698.7 ms ±  10.3 ms    [User: 2730.8 ms, System: 18.3 ms]
  Range (min … max):   680.9 ms … 721.7 ms    10 runs

Benchmark 4: ./spectralnorm_par.exe 8 4096
  Time (mean ± sd):    921.8 ms ±  52.1 ms    [User: 6711.6 ms, System: 51.0 ms]
  Range (min … max):   838.6 ms … 989.2 ms    10 runs

Summary
  './spectralnorm_par.exe 4 4096' ran
    1.32 ± 0.08 times faster than './spectralnorm_par.exe 8 4096'
    1.55 ± 0.03 times faster than './spectralnorm_par.exe 2 4096'
    2.85 ± 0.05 times faster than './spectralnorm.exe 4096'
</pre><p>
On the author’s machine, the program scales well up to 4 domains but performs
worse with 8 domains. This is due to the fact that unlike parallel Fibonacci
program, this program performs floating-point computations. At 8 domains, the
hyper-threaded siblings contend for the shared floating-point units on a core
leading to worse behaviour than at 4 domains.</p>
<h2 class="section" id="s:gc"><a class="section-anchor" href="#s:gc" aria-hidden="true">﻿</a><span class="number">3</span> Parallel garbage collection</h2>
<p>An important aspect of the scalability of parallel OCaml programs is the
scalability of the garbage collector (GC). The OCaml GC is designed to have
both low latency and good parallel scalability. OCaml has a generational
garbage collector with a small minor heap and a large major heap. New objects
(upto a certain size) are allocated in the minor heap. Each domain has its own
domain-local minor heap arena into which new objects are allocated without
synchronizing with the other domains. When a domain exhausts its minor heap
arena, it calls for a stop-the-world collection of the minor heap. In the
stop-the-world section, all the domains collect their minor heap arenas in
parallel evacuating the survivors to the major heap.</p><p>For the major heap, each domain maintains domain-local, size-segmented pools of
memory into which large objects and survivors from the minor collection are
allocated. Having domain-local pools avoids synchronization for most major heap
allocations. The major heap is collected by a concurrent mark-and-sweep
algorithm that involves a few short stop-the-world pauses for each major cycle.</p><p>Overall, the users should expect the garbage collector to scale well with
increasing number of domains, with the latency remaining low. For more
information on the design and evaluation of the garbage collector, please have
a look at the ICFP 2020 paper on
<a href="https://arxiv.org/abs/2004.11663"><span class="machine"><span class="font-tt">Retrofitting Parallelism onto OCaml</span></span></a>.</p>
<h2 class="section" id="s:mm_easy"><a class="section-anchor" href="#s:mm_easy" aria-hidden="true">﻿</a><span class="number">4</span> Memory model: The easy bits</h2>
<p>Modern processors and compilers aggressively optimise programs. These
optimisations accelerate without otherwise affecting sequential programs, but
cause surprising behaviours to be visible in parallel programs. To benefit from
these optimisations, OCaml adopts a <span class="font-it">weak memory model</span> that precisely
specifies which of these <em>relaxed behaviours</em> programs may observe. While
these models are difficult to program against directly, the OCaml memory model
provides recipes that retains the simplicity of sequential reasoning.</p><p>Firstly, immutable values may be freely shared between multiple domains and may
be accessed in parallel. For mutable data structures such as reference cells,
arrays and mutable record fields, programmers should avoid <em>data races</em>.
Reference cells, arrays and mutable record fields are said to be
<em>non-atomic</em> data structures. A data race is said to occur when two
domains concurrently access a non-atomic memory location without
<em>synchronization</em> and at least one of the accesses is a write. OCaml
provides a number of ways to introduce synchronization including atomic
variables ‍<a href="#s%3Aatomics">9.5</a> and mutexes ‍<a href="#s%3Async">9.6</a>.</p><p>Importantly, <span class="font-bold">for data race free (DRF) programs, OCaml provides
sequentially consistent (SC) semantics</span> – the observed behaviour of such
programs can be explained by the interleaving of operations from different
domains. This property is known as DRF-SC guarantee. Moreover, in OCaml, DRF-SC
guarantee is modular – if a part of a program is data race free, then the
OCaml memory model ensures that those parts have sequential consistency despite
other parts of the program having data races. Even for programs with data
races, OCaml provides strong guarantees. While the user may observe non
sequentially consistent behaviours, there are no crashes.</p><p>For more details on the relaxed behaviours in the presence of data races,
please have a look at the chapter on the hard bits of the memory model (TODO:
ref).</p>
<h2 class="section" id="s:atomics"><a class="section-anchor" href="#s:atomics" aria-hidden="true">﻿</a><span class="number">5</span> Atomics</h2>
<p>One way to avoid data races is to use <a href="../api/Atomic.html"><span class="font-tt">Atomic</span></a> variables for
inter-domain synchronization. Importantly, racy access to shared atomic
locations in parallel is not a data race. Hence, the program will only exhibit
sequentially consistent behaviour.</p><p>The following program increments a non-atomic and an atomic counter in
parallel.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* incr.ml *)</span>
<span class="ocamlkeyword">let</span> twice_in_parallel f =
  <span class="ocamlkeyword">let</span> d1 = Domain.spawn f <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> d2 = Domain.spawn f <span class="ocamlkeyword">in</span>
  ignore @@ Domain.join d1;
  ignore @@ Domain.join d2

<span class="ocamlkeyword">let</span> plain_ref n =
  <span class="ocamlkeyword">let</span> r = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> f () = <span class="ocamlkeyword">for</span> _i=1 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span> incr r <span class="ocamlkeyword">done</span> <span class="ocamlkeyword">in</span>
  twice_in_parallel f;
  Printf.printf <span class="ocamlstring">"Non-atomic ref count: %d\n"</span> !r

<span class="ocamlkeyword">let</span> atomic_ref n =
  <span class="ocamlkeyword">let</span> r = Atomic.make 0 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> f () = <span class="ocamlkeyword">for</span> _i=1 <span class="ocamlkeyword">to</span> n <span class="ocamlkeyword">do</span> Atomic.incr r <span class="ocamlkeyword">done</span> <span class="ocamlkeyword">in</span>
  twice_in_parallel f;
  Printf.printf <span class="ocamlstring">"Atomic ref count: %d\n"</span> (Atomic.get r)

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> n = <span class="ocamlkeyword">try</span> int_of_string Sys.argv.(1) <span class="ocamlkeyword">with</span> _ -&gt; 1 <span class="ocamlkeyword">in</span>
  plain_ref n;
  atomic_ref n

<span class="ocamlkeyword">let</span> _ = main ()</div></div>

</div><pre>$ ocamlopt -o incr.exe incr.ml
$ ./incr.exe 1_000_000
Non-atomic ref count: 1187193
Atomic ref count: 2000000
</pre><p>
As one can see, the non-atomic increment undercounts.</p>
<h3 class="subsection" id="s:lockfree_stack"><a class="section-anchor" href="#s:lockfree_stack" aria-hidden="true">﻿</a><span class="number">5.1</span> Lock-free stack</h3>
<p>The Atomic module is used to implement non-blocking, lock-free data structures.
The following program implements a lock-free stack.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> Lockfree_stack : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> 'a t
  <span class="ocamlkeyword">val</span> make : unit -&gt; 'a t
  <span class="ocamlkeyword">val</span> push : 'a t -&gt; 'a -&gt; unit
  <span class="ocamlkeyword">val</span> pop  : 'a t -&gt; 'a option
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> 'a t = 'a list Atomic.t

  <span class="ocamlkeyword">let</span> make () = Atomic.make []

  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> push r v =
    <span class="ocamlkeyword">let</span> s = Atomic.get r <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">if</span> Atomic.compare_and_set r s (v::s) <span class="ocamlkeyword">then</span> ()
    <span class="ocamlkeyword">else</span> (Domain.cpu_relax (); push r v)

  <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> pop r =
    <span class="ocamlkeyword">let</span> s = Atomic.get r <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">match</span> s <span class="ocamlkeyword">with</span>
    | [] -&gt; None
    | x::xs -&gt;
        <span class="ocamlkeyword">if</span> Atomic.compare_and_set r s xs <span class="ocamlkeyword">then</span> Some x
        <span class="ocamlkeyword">else</span> (Domain.cpu_relax (); pop r)
<span class="ocamlkeyword">end</span></div></div>

</div><p>The atomic stack is represented by an atomic reference that holds a list. The
<span class="machine"><span class="font-tt">push</span></span> and <span class="machine"><span class="font-tt">pop</span></span> operations use the <span class="machine"><span class="font-tt">compare_and_set</span></span> primitive to attempt to
atomically update the atomic reference. The expression <span class="machine"><span class="font-tt">compare_and_set r seen v</span></span> sets the value of <span class="machine"><span class="font-tt">r</span></span> to <span class="machine"><span class="font-tt">v</span></span> if and only if its current value is physically
equal to <span class="machine"><span class="font-tt">seen</span></span>. Importantly, the comparison and the set occur atomically. The
expression evaluates to <span class="machine"><span class="font-tt">true</span></span> if the comparison succeeded (so the set
happened) and <span class="machine"><span class="font-tt">false</span></span> otherwise.</p><p>If the <span class="machine"><span class="font-tt">compare_and_set</span></span> fails, then some other domain is also attempting to
update the atomic reference at the same time. In this case, the <span class="machine"><span class="font-tt">push</span></span> and
<span class="machine"><span class="font-tt">pop</span></span> operations call <span class="machine"><span class="font-tt">Domain.cpu_relax</span></span> to back off for a short duration
allowing competing domains to make progress before retrying the failed
operation.</p>
<h2 class="section" id="s:sync"><a class="section-anchor" href="#s:sync" aria-hidden="true">﻿</a><span class="number">6</span> Blocking synchronization</h2>
<p>Domains may also perform blocking synchronization with the help of
<a href="../api/Mutex.html"><span class="font-tt">Mutex</span></a>, <a href="../api/Condition.html"><span class="font-tt">Condition</span></a> and <a href="../api/Semaphore.html"><span class="font-tt">Semaphore</span></a>
modules. These modules are the same as those used to synchronize threads
created by the threads library ‍<a href="libthreads.html#c%3Athreads">31</a>. For clarity, in the rest of
this chapter, we shall call the threads created by the threads library as
systhreads. The following program implements a blocking version of a concurrent
stack using mutex and condition variables.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">module</span> Blocking_stack : <span class="ocamlkeyword">sig</span>
  <span class="ocamlkeyword">type</span> 'a t
  <span class="ocamlkeyword">val</span> make : unit -&gt; 'a t
  <span class="ocamlkeyword">val</span> push : 'a t -&gt; 'a -&gt; unit
  <span class="ocamlkeyword">val</span> pop  : 'a t -&gt; 'a
<span class="ocamlkeyword">end</span> = <span class="ocamlkeyword">struct</span>
  <span class="ocamlkeyword">type</span> 'a t = {
    <span class="ocamlkeyword">mutable</span> contents: 'a list;
    mutex : Mutex.t;
    condition : Condition.t
  }

  <span class="ocamlkeyword">let</span> make () = {
    contents = [];
    mutex = Mutex.create ();
    condition = Condition.create ()
  }

  <span class="ocamlkeyword">let</span> push r v =
    Mutex.lock r.mutex;
    r.contents &lt;- v::r.contents;
    Condition.signal r.condition;
    Mutex.unlock r.mutex

  <span class="ocamlkeyword">let</span> pop r =
    Mutex.lock r.mutex;
    <span class="ocamlkeyword">let</span> <span class="ocamlkeyword">rec</span> loop () =
      <span class="ocamlkeyword">match</span> r.contents <span class="ocamlkeyword">with</span>
      | [] -&gt;
          Condition.wait r.condition r.mutex;
          loop ()
      | x::xs -&gt; r.contents &lt;- xs; x
    <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">let</span> res = loop () <span class="ocamlkeyword">in</span>
    Mutex.unlock r.mutex;
    res
<span class="ocamlkeyword">end</span></div></div>

</div><p>Unlike the non-blocking version described earlier, the <span class="machine"><span class="font-tt">pop</span></span> operation blocks
the calling domain if the stack is empty. The domain is unblocked when a
subsequent <span class="machine"><span class="font-tt">push</span></span> operation is performed on this stack.</p>
<h3 class="subsection" id="s:systhread_intereaction"><a class="section-anchor" href="#s:systhread_intereaction" aria-hidden="true">﻿</a><span class="number">6.1</span> Interaction with systhreads</h3>
<p>How do systhreads interact with domains? The systhreads created on a particular
domain remain pinned to that domain. Only one systhread at a time is allowed to
run OCaml code on a particular domain. However, systhreads belonging to a
particular domain may run C library or system code in parallel. Systhreads
belonging to different domains may execute in parallel.</p><p>When using systhreads, the thread created for executing the computation given
to <span class="machine"><span class="font-tt">Domain.spawn</span></span> is also treated as a systhread. For example, the following
program creates in total two domains (including the initial domain) with two
systhreads each (including the initial systhread for each of the domains).</p><pre>(* dom_thr.ml *)
let m = Mutex.create ()
let r = ref None (* protected by m *)

let task () =
  let my_thr_id = Thread.(id (self ())) in
  let my_dom_id :&gt; int = Domain.self () in
  Mutex.lock m;
  begin match !r with
  | None -&gt;
      Printf.printf "Thread %d running on domain %d saw initial write\n%!"
        my_thr_id my_dom_id
  | Some their_thr_id -&gt;
      Printf.printf "Thread %d running on domain %d saw the write by thread %d\n%!"
        my_thr_id my_dom_id their_thr_id;
  end;
  r := Some my_thr_id;
  Mutex.unlock m

let task' () =
  let t = Thread.create task () in
  task ();
  Thread.join t

let main () =
  let d = Domain.spawn task' in
  task' ();
  Domain.join d

let _ = main ()
</pre><pre>$ ocamlopt -I +threads unix.cmxa threads.cmxa -o dom_thr.exe dom_thr.ml
$ ./dom_thr.exe
Thread 1 running on domain 1 saw initial write
Thread 0 running on domain 0 saw the write by thread 1
Thread 2 running on domain 1 saw the write by thread 0
Thread 3 running on domain 0 saw the write by thread 2
</pre><p>
This program uses a shared reference cell protected by a mutex to communicate
between the different systhreads running on two different domains. The
systhread identifiers are unique to each systhread in the program. The initial
domain gets the domain id and the thread id as 0. The newly spawned domain gets
domain id as 1.
</p>
<hr>
<div class="bottom-navigation"><a class="previous" href="advexamples.html">« Advanced examples with classes and modules</a><a class="next" href="language.html">The OCaml language »</a></div>




<div class="copyright">Copyright © 2022 Institut National de
Recherche en Informatique et en Automatique</div></div></body></html>