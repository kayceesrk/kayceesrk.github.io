<!DOCTYPE html><html lang="en"><head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.35">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>OCaml - Memory model: The hard bits</title>
<script src="scroll.js"></script><script src="navigation.js"></script><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></head>
<body><div class="content manual"><div id="sidebar-button"><span>☰</span></div><nav id="part-title"><span>☰</span>An introduction to OCaml</nav><ul id="part-menu"><li><a href="coreexamples.html">The core language</a></li><li><a href="moduleexamples.html">The module system</a></li><li><a href="objectexamples.html">Objects in OCaml</a></li><li><a href="lablexamples.html">Labeled arguments</a></li><li><a href="polyvariant.html">Polymorphic variants</a></li><li><a href="polymorphism.html">Polymorphism and its limitations</a></li><li><a href="gadts-tutorial.html">Generalized algebraic datatypes</a></li><li><a href="advexamples.html">Advanced examples with classes and modules</a></li><li><a href="parallelism.html">Parallel programming</a></li><li class="active"><a href="memorymodel.html">Memory model: The hard bits</a></li></ul>




<h1 class="chapter" id="sec91"><span class="chapter-number">Chapter 10</span> Memory model: The hard bits</h1>
<header id="sidebar"><nav class="toc brand"><a class="brand" href="https://ocaml.org/"><img src="colour-logo.svg" class="svg" alt="OCaml"></a></nav><nav class="toc"><div class="toc_version"><a id="version-select" href="https://ocaml.org/releases/">Version 5.0</a></div><div class="toc_title"><a href="index.html">&lt; The OCaml Manual</a></div><ul><li class="top"><a href="#">Memory model: The hard bits</a></li>
<li><a href="memorymodel.html#s%3Awhy_weak_memory"><span class="number">1</span> Why do we need a weak memory model?</a>
</li><li><a href="memorymodel.html#s%3Adrf_sc"><span class="number">2</span> Data race freedom implies sequential consistency</a>
</li><li><a href="memorymodel.html#s%3Adrf_reasoning"><span class="number">3</span> Reasoning with DRF-SC</a>
</li><li><a href="memorymodel.html#s%3Alocal_drf"><span class="number">4</span> Local data race freedom</a>
</li><li><a href="memorymodel.html#s%3Atearing"><span class="number">5</span> Non-compliant operations</a>
</li></ul></nav></header>
<p>
<a id="c:memorymodel"></a></p><p>(WIP)</p><p>This chapter describes the details of OCaml weak memory model. The weak memory
model describes what values an OCaml program is allowed to witness when reading
a memory location. If you are interested in high-level parallel programming in
OCaml, please have a look at the parallel programming chapter
<a href="parallelism.html#c%3Aparallelism">9</a>.</p><p>This chapter is aimed at experts who would like to understand the details of
the OCaml memory model from a practitioners standpoint. For a formal definition
of the OCaml memory model, its guarantees and the compilation to hardware
memory model, please have a look at the PLDI 2018 paper on
<a href="https://doi.org/10.1145/3192366.3192421">Bounding Data Races in Space and
Time</a>.</p>
<h2 class="section" id="s:why_weak_memory"><a class="section-anchor" href="#s:why_weak_memory" aria-hidden="true"></a><span class="number">1</span> Why do we need a weak memory model?</h2>
<p>The simplest memory model that we could give to our programs is sequential
consistency. Under sequential consistency, the values observed by the program
can be explained through some interleaving of the operations from different
domains in the program.</p><p>For example, consider the program with two domains <span class="machine"><span class="font-tt">d1</span></span> and <span class="machine"><span class="font-tt">d2</span></span> executing in
parallel:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  (r1, r2, r3)

<span class="ocamlkeyword">let</span> d2 b = b := 0</div></div>

</div><p>Assuming <span class="machine"><span class="font-tt">!a = 1, !b = 1</span></span> initially, the user may observe <span class="machine"><span class="font-tt">r1 = 2, r2 = 0, r3 = 2</span></span> if the write to <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d2</span></span> occurred before the read of <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d1</span></span>. Here,
the observed behaviour can be explained in terms of interleaving of the
operations from different domains.</p><p>The OCaml compiler observes the common sub-expression (CSE) <span class="machine"><span class="font-tt">!a * 2</span></span> in <span class="machine"><span class="font-tt">d1</span></span>
and optimises the program to</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = r1 <span class="ocamlkeyword">in</span>
  (r1, r2, r3)</div></div>

</div><p>Such optimisations are valid and necessary for good performance, and do not
change the sequential meaning of the program. However, CSE breaks sequential
consistency. For example, assume that <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are aliases of each other.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> r = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> h = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> r1, r2, r3 = d1 r r <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">assert</span> (not (r1 = 2 &amp;&amp; r2 = 0 &amp;&amp; r3 = 2)))
  <span class="ocamlkeyword">in</span>
  d2 r;
  Domain.join h</div></div>

</div><p>Looking at the unoptimized program, the above snippet can never trigger the
assertion failure. However, due to CSE, in the optimized program, when the
write to <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d2</span></span> occurs before the read of <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d1</span></span>, <span class="machine"><span class="font-tt">d1</span></span> returns
<span class="machine"><span class="font-tt">(2,0,2)</span></span> and the assertion fails. The observed behaviour cannot be explained
by interleaving of operations from different domains in the source program.
Thus, CSE optimization breaks sequential consistency.</p><p>One way to explain the observed behaviour is as if the operations performed on
a domain were reordered. For example, if the second and the third reads from
<span class="machine"><span class="font-tt">d2</span></span> were reordered,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  (r1, r2, r3)</div></div>

</div><p>then we can explain the observed behaviour <span class="machine"><span class="font-tt">(2,0,2)</span></span> returned by
<span class="machine"><span class="font-tt">d1</span></span>.</p><p>The other source of reordering is by the hardware. Modern hardware
architectures have complex cache hierarchies with multiple levels of cache.
While cache coherence ensures that reads and writes to a single memory
location respect sequential consistency, the guarantees on programs that
operate on different memory locations are much weaker. Consider the following
program:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">and</span> b = <span class="ocamlkeyword">ref</span> 0

<span class="ocamlkeyword">let</span> d1 () =
  a := 1;
  !b

<span class="ocamlkeyword">let</span> d2 () =
  b := 1;
  !a

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> h = Domain.spawn d2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r1 = d1 () <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = Domain.join h <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">assert</span> (not (r1 = 0 &amp;&amp; r2 = 0))</div></div>

</div><p>Under sequential consistency, we would never expect the assertion to fail.
However, even on x86, which offers much stronger guarantees than the ARM, the
writes performed at a CPU core are not immediately published to all of the
other cores. Since <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are different memory locations, the reads of <span class="machine"><span class="font-tt">a</span></span>
and <span class="machine"><span class="font-tt">b</span></span> may both witness the initial values, leading to the assertion failure.
This behaviour can be explained if a load is allowed to be reordered before a
preceding store to a different memory location.</p>
<h2 class="section" id="s:drf_sc"><a class="section-anchor" href="#s:drf_sc" aria-hidden="true">﻿</a><span class="number">2</span> Data race freedom implies sequential consistency</h2>
<p>The aim of the OCaml weak memory model is to precisely describe which orders
are preserved by the OCaml program. The compiler and the hardware are free to
optimize the program as long as they respect the ordering guarantees of the
memory model. While programming directly under the weak memory model is
difficult, the memory model also describes the conditions under which a program
will only exhibit sequentially consistent behaviours. This guarantee is known
as data race freedom implies sequential consistency (DRF-SC). In this section,
we shall describe this guarantee. In order to do this, we first need a number
of definitions.</p>
<h3 class="subsection" id="sec94"><a class="section-anchor" href="#sec94" aria-hidden="true">﻿</a><span class="number">2.1</span> Memory locations</h3>
<p>OCaml classifies memory locations into <em>atomic</em> and <em>non-atomic</em>
locations. Reference cells, array fields and mutable record fields are
non-atomic memory locations. Immutable objects are non-atomic locations with an
initialising write but no further updates. Atomic memory locations are those
that are created using the <a href="../api/Atomic.html"><span class="font-tt">Atomic</span></a> module.</p>
<h3 class="subsection" id="s:happens_before"><a class="section-anchor" href="#s:happens_before" aria-hidden="true">﻿</a><span class="number">2.2</span> Happens-before relation</h3>
<p>Let us imagine that the OCaml programs are executed by an abstract machine that
executes one action at a time, arbitrarily picking one of the available domains
at each step. We classify actions into two: <em>inter-domain</em> and
<em>intra-domain</em>. An inter-domain action is one which can be observed and be
influenced by actions on other domains. There are several inter-domain actions:</p><ul class="itemize"><li class="li-itemize">
Reads and writes of atomic and non-atomic locations.
</li><li class="li-itemize">Spawn and join of domains.
</li><li class="li-itemize">Operations on mutexes.
</li></ul><p><em>(TODO: Include semaphores and condition variables in inter-domain
actions.)</em></p><p>On the other hand, an intra-domain actions can neither be observed nor
influence the execution of other domains. Examples include evaluating an
arithmetic expression, calling a function, etc. The memory model specification
ignores such intra-domain actions. In the sequel, we use the term action to
indicate inter-domain actions.</p><p>A totally ordered list of actions executed by the abstract machine is called
the <em>execution trace</em>. There might be several execution traces for a given
program due to non-determinism.</p><p>For a given execution trace, we define an irreflexive, transitive
<em>happens-before relation</em> that captures the causality between actions in
the OCaml program. The happens-before relation is defined as follows:</p><ul class="itemize"><li class="li-itemize">
We define the order in which a domain executes its actions as the
<em>program order</em>. If an action <span class="machine"><span class="font-tt">x</span></span> precedes another action <span class="machine"><span class="font-tt">y</span></span> in
program order, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is an initialising write to a memory location (atomic or
otherwise) and <span class="machine"><span class="font-tt">y</span></span> is any read or write to that memory location, then <span class="machine"><span class="font-tt">x</span></span>
precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is a write to an atomic location and <span class="machine"><span class="font-tt">y</span></span> is a subsequent read or
write to that memory location in the execution trace, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span>
in happens-before order. For atomic locations, <span class="machine"><span class="font-tt">compare_and_set</span></span>,
<span class="machine"><span class="font-tt">fetch_and_add</span></span>, <span class="machine"><span class="font-tt">exchange</span></span>, <span class="machine"><span class="font-tt">incr</span></span> and <span class="machine"><span class="font-tt">decr</span></span> are considered to perform
both a read and a write.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is <span class="machine"><span class="font-tt">Domain.spawn f</span></span> and <span class="machine"><span class="font-tt">y</span></span> is the first action in the newly
spawned domain executing <span class="machine"><span class="font-tt">f</span></span>, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before
order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is the last action in a domain <span class="machine"><span class="font-tt">d</span></span> and <span class="machine"><span class="font-tt">y</span></span> is <span class="machine"><span class="font-tt">Domain.join     d</span></span>, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is an unlock operation on a mutex, and <span class="machine"><span class="font-tt">y</span></span> is any subsequent
operation on the mutex in the execution trace, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in
happens-before order.
</li></ul>
<h3 class="subsection" id="s:datarace"><a class="section-anchor" href="#s:datarace" aria-hidden="true">﻿</a><span class="number">2.3</span> Data race</h3>
<p>In a given trace, two actions are said to be <em>conflicting</em> if they access
the same non-atomic location, and at least one is a write.</p><p>We say that a program has a <em>data race</em> if there exists some execution
trace of the program with two conflicting actions and there does not exist a
happens-before relationship between the conflicting accesses. A program without
data races is said to be <em>correctly synchronised</em>.</p>
<h3 class="subsection" id="ss:drf_sc"><a class="section-anchor" href="#ss:drf_sc" aria-hidden="true">﻿</a><span class="number">2.4</span> DRF-SC</h3>
<p><span class="font-bold">DRF-SC guarantee:</span> A program without data races will only exhibit
sequentially consistent behaviours.</p><p>DRF-SC is a strong guarantee for the programmers. Programmers can use
sequential reasoning (executing one inter-domain action to identify whether
their program has a data race. In particular, they do not need to reason about
reorderings described in section ‍<a href="#s%3Awhy_weak_memory">10.1</a> in order to determine
whether their program has a data race. Once the determination that a particular
program is data race free is made, they do not need to worry about reorderings
in their code.</p><p>For programs with data races, OCaml memory model ensures that there are no
out-of-thin-air (OOTA) values. Reads always return a value written to a memory
location (including possibly be the initial write). Data races do not cause
programs to crash.</p>
<h2 class="section" id="s:drf_reasoning"><a class="section-anchor" href="#s:drf_reasoning" aria-hidden="true">﻿</a><span class="number">3</span> Reasoning with DRF-SC</h2>
<p>In this section, we will look at examples of using DRF-SC for program
reasoning. In this section, we will use the functions with names <span class="machine"><span class="font-tt">dN</span></span> to
represent domains executing in parallel with other domains.</p><p>Here is a simple example with a data race:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* Has data race *)</span>
<span class="ocamlkeyword">let</span> r = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">let</span> d1 () = <span class="ocamlkeyword">ref</span> 1
<span class="ocamlkeyword">let</span> d2 () = !r</div></div>

</div><p><span class="machine"><span class="font-tt">r</span></span> is a non-atomic reference. The two domains race to access the reference,
and <span class="machine"><span class="font-tt">d1</span></span> is a write. Since there is no happens-before relationship between the
conflicting accesses, there is a data race.</p><p>Accessing disjoint array indices and fields of a record in parallel is not a
data race. For example,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> a = [| 0; 1 |]
<span class="ocamlkeyword">let</span> d1 = a.(0) &lt;- 42
<span class="ocamlkeyword">let</span> d2 = a.(1) &lt;- 42</div></div>

</div><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">type</span> t = {
  <span class="ocamlkeyword">mutable</span> a : int;
  <span class="ocamlkeyword">mutable</span> b : int
}
<span class="ocamlkeyword">let</span> r = {a = 0; b = 1}
<span class="ocamlkeyword">let</span> d1 = r.a &lt;- 42
<span class="ocamlkeyword">let</span> d2 = r.b &lt;- 42</div></div>

</div><p>do not have data races.</p><p>Races on atomic locations do not lead to a data race.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> r = Atomic.make 0
<span class="ocamlkeyword">let</span> d1 () = Atomic.set r 1
<span class="ocamlkeyword">let</span> d2 () = Atomic.get r</div></div>

</div><p>Atomic variables may be used for implementing non-blocking communication
between domains.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> msg = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">let</span> flag = Atomic.make <span class="ocamlkeyword">false</span>
<span class="ocamlkeyword">let</span> d1 () =
  msg := 42; <span class="ocamlcomment">(* a *)</span>
  Atomic.set flag <span class="ocamlkeyword">true</span> <span class="ocamlcomment">(* b *)</span>
<span class="ocamlkeyword">let</span> d2 () =
  <span class="ocamlkeyword">if</span> Atomic.get flag <span class="ocamlcomment">(* c *)</span> <span class="ocamlkeyword">then</span>
    !msg <span class="ocamlcomment">(* d *)</span>
  <span class="ocamlkeyword">else</span> 0</div></div>

</div><p>Observe that the actions <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">d</span></span> write and read from the same non-atomic
location <span class="machine"><span class="font-tt">msg</span></span>, respectively, and hence are conflicting. We need to establish
that <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">d</span></span> have a happens-before relationship in order to show that this
program does not have a data race.</p><p>The action <span class="machine"><span class="font-tt">a</span></span> precedes <span class="machine"><span class="font-tt">b</span></span> in program order, and hence, <span class="machine"><span class="font-tt">a</span></span> happens-before
<span class="machine"><span class="font-tt">b</span></span>. Similarly, <span class="machine"><span class="font-tt">c</span></span> happens-before <span class="machine"><span class="font-tt">d</span></span>. If <span class="machine"><span class="font-tt">d2</span></span> observes the atomic variable
<span class="machine"><span class="font-tt">flag</span></span> to be <span class="machine"><span class="font-tt">true</span></span>, then <span class="machine"><span class="font-tt">b</span></span> precedes <span class="machine"><span class="font-tt">c</span></span> in happens-before order. Since
happens-before is transitive, the conflicting actions <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">d</span></span> are in
happens-before order. If <span class="machine"><span class="font-tt">d2</span></span> observes the <span class="machine"><span class="font-tt">flag</span></span> to be <span class="machine"><span class="font-tt">false</span></span>, then the read
of <span class="machine"><span class="font-tt">msg</span></span> is not done. Hence, there is no conflicting access in this execution
trace. Hence, the program does not have a data race.</p><p>The following modified version of the message passing program does have a data
race.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlcomment">(* No data race *)</span>
<span class="ocamlkeyword">let</span> msg = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">let</span> flag = Atomic.make <span class="ocamlkeyword">false</span>
<span class="ocamlkeyword">let</span> d1 () =
  msg := 42; <span class="ocamlcomment">(* a *)</span>
  Atomic.set flag <span class="ocamlkeyword">true</span> <span class="ocamlcomment">(* b *)</span>
<span class="ocamlkeyword">let</span> d2 () =
  ignore (Atomic.get flag); <span class="ocamlcomment">(* c *)</span>
  !msg <span class="ocamlcomment">(* d *)</span></div></div>

</div><p>The domain <span class="machine"><span class="font-tt">d2</span></span> now unconditionally reads the non-atomic reference <span class="machine"><span class="font-tt">msg</span></span>.
Consider the execution trace:</p><pre>Atomic.get flag; (* c *)
!msg; (* d *)
msg := 42; (* a *)
Atomic.set flag true (* b *)
</pre><p>
In this trace, <span class="machine"><span class="font-tt">d</span></span> and <span class="machine"><span class="font-tt">a</span></span> are conflicting operations. But there is no
happens-before relationship between them. Hence, this program has a data race.</p><p>Both of the programs that we had seen in the section ‍<a href="#s%3Awhy_weak_memory">10.1</a>
have have data races, and hence, exhibit non sequentially consistent
behaviours.</p>
<h2 class="section" id="s:local_drf"><a class="section-anchor" href="#s:local_drf" aria-hidden="true">﻿</a><span class="number">4</span> Local data race freedom</h2>
<p>OCaml memory model offers strong guarantees even for programs with data races.
It offers what is known as <em>local data race freedom sequential
consistency(LDRF-SC)</em> guarantee. A formal definition of this property is beyond
the scope of this manual chapter. Interested readers are encouraged to read the
PLDI 2018 paper on <a href="https://doi.org/10.1145/3192366.3192421">Bounding Data
Races in Space and Time</a>.</p><p>Informally, LDRF-SC says that the data race free parts of the program remain
sequentially consistent. That is, even if the program has data races, those
parts of the program that are disjoint from the parts with data races are
amenable to sequential reasoning.</p><p>Consider the following snippet:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> snippet () =
  <span class="ocamlkeyword">let</span> c = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
  c := 42;
  <span class="ocamlkeyword">let</span> a = !c <span class="ocamlkeyword">in</span>
  a</div></div>

</div><p>Observe that <span class="machine"><span class="font-tt">c</span></span> is a newly allocated reference. Can the read of <span class="machine"><span class="font-tt">c</span></span> return a
value which is not 42? Surprisingly, in the C++ and Java memory models, the
answer is yes. With the C++ memory model, if the program has a data race, even
in unrelated parts, then the semantics is undefined. If this snippet were
linked with a library that had a data race, then, under the C++ memory model,
the read may return any value. Since data races on unrelated locations can
affect program behaviour, we say that C++ memory model is not bound in space.</p><p>Unlike C++, Java memory model is bound in space. But Java memory model is not
bound in time; data races in the future will affect the past behaviour. For
example, consider the translation of this example to Java. We assume a prior
definition of <span class="machine"><span class="font-tt">Class c {int x;}</span></span> and a shared <em>non-volatile</em> variable <span class="machine"><span class="font-tt">C g</span></span>. Now the snippet may be part of a larger program with parallel threads:</p><pre>(* Thread 1 *)
C c = new C();
c.x = 42;
a = c.x;
g = c;

(* Thread 2 *)
g.x = 7;
</pre><p>
The read of <span class="machine"><span class="font-tt">c.x</span></span> and the write of <span class="machine"><span class="font-tt">g</span></span> in the first thread are done on separate
memory locations. Hence, the Java memory model allows them to be reordered. As
a result, the write in the second thread may occur before the read of <span class="machine"><span class="font-tt">c.x</span></span>,
and hence, <span class="machine"><span class="font-tt">c.x</span></span> returns <span class="machine"><span class="font-tt">7</span></span>.</p><p>The OCaml equivalent of the Java code above is:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> g = <span class="ocamlkeyword">ref</span> None

<span class="ocamlkeyword">let</span> d1 () =
  <span class="ocamlkeyword">let</span> c = <span class="ocamlkeyword">ref</span> 0 <span class="ocamlkeyword">in</span>
  c := 42;
  <span class="ocamlkeyword">let</span> a = !c <span class="ocamlkeyword">in</span>
  g := Some c;
  a

<span class="ocamlkeyword">let</span> d2 () =
  <span class="ocamlkeyword">match</span> !g <span class="ocamlkeyword">with</span>
  | None -&gt; ()
  | Some c -&gt; c := 7</div></div>

</div><p>Observe that there is a data race on both <span class="machine"><span class="font-tt">g</span></span> and <span class="machine"><span class="font-tt">c</span></span>. Consider only the first
three instructions in <span class="machine"><span class="font-tt">d1</span></span>:</p><pre>let c = ref 0 in
c := 42;
let a = !c in
...
</pre><p>
OCaml memory model is bound both in space and time. The only memory location
here is <span class="machine"><span class="font-tt">c</span></span>. Reasoning only about this snippet, there is neither the data race
in space (the race on <span class="machine"><span class="font-tt">g</span></span>) nor in time (the future race on <span class="machine"><span class="font-tt">c</span></span>). Hence, the
snippet will have sequentially consistent behaviour, and the value returned by
<span class="machine"><span class="font-tt">!c</span></span> will be <span class="machine"><span class="font-tt">42</span></span>.</p>
<h2 class="section" id="s:tearing"><a class="section-anchor" href="#s:tearing" aria-hidden="true">﻿</a><span class="number">5</span> Non-compliant operations</h2>
<ul class="itemize"><li class="li-itemize">
<span class="machine"><span class="font-tt">Array.blit</span></span> on float arrays.
</li><li class="li-itemize">32-bit flat-float arrays: Getting and setting is not an atomic operation.
</li><li class="li-itemize">Tearing with mixed-sized accesses on Bytes.
</li></ul>
<hr>
<div class="bottom-navigation"><a class="previous" href="parallelism.html">« Parallel programming</a><a class="next" href="language.html">The OCaml language »</a></div>




<div class="copyright">Copyright © 2022 Institut National de
Recherche en Informatique et en Automatique</div></div></body></html>