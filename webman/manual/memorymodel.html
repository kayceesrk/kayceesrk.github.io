<!DOCTYPE html><html lang="en"><head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.35">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>OCaml - Memory model: The hard bits</title>
<script src="scroll.js"></script><script src="navigation.js"></script><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></head>
<body><div class="content manual"><div id="sidebar-button"><span>☰</span></div><nav id="part-title"><span>☰</span>An introduction to OCaml</nav><ul id="part-menu"><li><a href="coreexamples.html">The core language</a></li><li><a href="moduleexamples.html">The module system</a></li><li><a href="objectexamples.html">Objects in OCaml</a></li><li><a href="lablexamples.html">Labeled arguments</a></li><li><a href="polyvariant.html">Polymorphic variants</a></li><li><a href="polymorphism.html">Polymorphism and its limitations</a></li><li><a href="gadts-tutorial.html">Generalized algebraic datatypes</a></li><li><a href="advexamples.html">Advanced examples with classes and modules</a></li><li><a href="parallelism.html">Parallel programming</a></li><li class="active"><a href="memorymodel.html">Memory model: The hard bits</a></li></ul>




<h1 class="chapter" id="sec91"><span class="chapter-number">Chapter 10</span> Memory model: The hard bits</h1>
<header id="sidebar"><nav class="toc brand"><a class="brand" href="https://ocaml.org/"><img src="colour-logo.svg" class="svg" alt="OCaml"></a></nav><nav class="toc"><div class="toc_version"><a id="version-select" href="https://ocaml.org/releases/">Version 5.0</a></div><div class="toc_title"><a href="index.html">&lt; The OCaml Manual</a></div><ul><li class="top"><a href="#">Memory model: The hard bits</a></li>
<li><a href="memorymodel.html#s%3Awhy_weak_memory"><span class="number">1</span> Why do we need a weak memory model?</a>
</li><li><a href="memorymodel.html#s%3Adrf_sc"><span class="number">2</span> Data race freedom implies sequential consistency</a>
</li><li><a href="memorymodel.html#s%3Adrf_reasoning"><span class="number">3</span> Reasoning with DRF-SC</a>
</li><li><a href="memorymodel.html#s%3Alocal_drf"><span class="number">4</span> Local data race freedom</a>
</li><li><a href="memorymodel.html#s%3Aldrf_reasoning"><span class="number">5</span> Reasoning with LDRF</a>
</li><li><a href="memorymodel.html#s%3Atearing"><span class="number">6</span> Operations that are not memory model compliant</a>
</li></ul></nav></header>
<p>
<a id="c:memorymodel"></a></p><p>(WIP)</p><p>This chapter describes the details of OCaml weak memory model. The weak memory
model describes what values an OCaml program is allowed to witness when reading
a memory location. If you are interested in high-level parallel programming in
OCaml, please have a look at the parallel programming chapter
<a href="parallelism.html#c%3Aparallelism">9</a>.</p><p>This chapter is aimed at experts who would like to understand the details of
the OCaml memory model from a practitioners standpoint. For a formal definition
of the OCaml memory model, its guarantees and the compilation to hardware
memory model, please have a look at the PLDI 2018 paper on
<a href="https://doi.org/10.1145/3192366.3192421">Bounding Data Races in Space and
Time</a>.</p>
<h2 class="section" id="s:why_weak_memory"><a class="section-anchor" href="#s:why_weak_memory" aria-hidden="true"></a><span class="number">1</span> Why do we need a weak memory model?</h2>
<p>The simplest memory model that we could give to our programs is sequential
consistency. Under sequential consistency, the values observed by the program
can be explained through some interleaving of the operations from different
domains in the program.</p><p>For example, consider the program with two domains <span class="machine"><span class="font-tt">d1</span></span> and <span class="machine"><span class="font-tt">d2</span></span> executing in
parallel:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  (r1, r2, r3)

<span class="ocamlkeyword">let</span> d2 b = b := 0</div></div>

</div><p>Assuming <span class="machine"><span class="font-tt">!a = 1, !b = 1</span></span> initially, the user may observe <span class="machine"><span class="font-tt">r1 = 2, r2 = 0, r3 = 2</span></span> if the write to <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d2</span></span> occurred before the read of <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d1</span></span>. Here,
the observed behaviour can be explained in terms of interleaving of the
operations from different domains.</p><p>The OCaml compiler observes the common sub-expression (CSE) <span class="machine"><span class="font-tt">!a * 2</span></span> in <span class="machine"><span class="font-tt">d1</span></span>
and optimises the program to</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = r1 <span class="ocamlkeyword">in</span>
  (r1, r2, r3)</div></div>

</div><p>Such optimisations are valid and necessary for good performance, and do not
change the sequential meaning of the program. However, CSE breaks sequential
consistency. For example, assume that <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are aliases of each other.</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> r = <span class="ocamlkeyword">ref</span> 1 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> h = Domain.spawn (<span class="ocamlkeyword">fun</span> _ -&gt;
    <span class="ocamlkeyword">let</span> r1, r2, r3 = d1 r r <span class="ocamlkeyword">in</span>
    <span class="ocamlkeyword">assert</span> (not (r1 = 2 &amp;&amp; r2 = 0 &amp;&amp; r3 = 2)))
  <span class="ocamlkeyword">in</span>
  d2 r;
  Domain.join h</div></div>

</div><p>Looking at the unoptimized program, the above snippet can never trigger the
assertion failure. However, due to CSE, in the optimized program, when the
write to <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d2</span></span> occurs before the read of <span class="machine"><span class="font-tt">b</span></span> in <span class="machine"><span class="font-tt">d1</span></span>, <span class="machine"><span class="font-tt">d1</span></span> returns
<span class="machine"><span class="font-tt">(2,0,2)</span></span> and the assertion fails. The observed behaviour cannot be explained
by interleaving of operations from different domains in the source program.
Thus, CSE optimization breaks sequential consistency.</p><p>One way to explain the observed behaviour is as if the operations performed on
a domain were reordered. For example, if the second and the third reads from
<span class="machine"><span class="font-tt">d2</span></span> were reordered,</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> d1 a b =
  <span class="ocamlkeyword">let</span> r1 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r3 = !a * 2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = !b <span class="ocamlkeyword">in</span>
  (r1, r2, r3)</div></div>

</div><p>then we can explain the observed behaviour <span class="machine"><span class="font-tt">(2,0,2)</span></span> returned by
<span class="machine"><span class="font-tt">d1</span></span>.</p><p>The other source of reordering is by the hardware. Modern hardware
architectures have complex cache hierarchies with multiple levels of cache.
While cache coherence ensures that reads and writes to a single memory
location respect sequential consistency, the guarantees on programs that
operate on different memory locations are much weaker. Consider the following
program:</p><div class="caml-example verbatim">

<div class="ocaml">



<div class="pre caml-input"><span class="ocamlkeyword">let</span> a = <span class="ocamlkeyword">ref</span> 0
<span class="ocamlkeyword">and</span> b = <span class="ocamlkeyword">ref</span> 0

<span class="ocamlkeyword">let</span> d1 () =
  a := 1;
  !b

<span class="ocamlkeyword">let</span> d2 () =
  b := 1;
  !a

<span class="ocamlkeyword">let</span> main () =
  <span class="ocamlkeyword">let</span> h = Domain.spawn d2 <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r1 = d1 () <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">let</span> r2 = Domain.join h <span class="ocamlkeyword">in</span>
  <span class="ocamlkeyword">assert</span> (not (r1 = 0 &amp;&amp; r2 = 0))</div></div>

</div><p>Under sequential consistency, we would never expect the assertion to fail.
However, even on x86, which offers much stronger guarantees than the ARM, the
writes performed at a CPU core are not immediately published to all of the
other cores. Since <span class="machine"><span class="font-tt">a</span></span> and <span class="machine"><span class="font-tt">b</span></span> are different memory locations, the reads of <span class="machine"><span class="font-tt">a</span></span>
and <span class="machine"><span class="font-tt">b</span></span> may both witness the initial values, leading to the assertion failure.
This behaviour can be explained if a load is allowed to be reordered before a
preceding store to different memory location.</p>
<h2 class="section" id="s:drf_sc"><a class="section-anchor" href="#s:drf_sc" aria-hidden="true">﻿</a><span class="number">2</span> Data race freedom implies sequential consistency</h2>
<p>The aim of the OCaml weak memory model is to precisely describe which orders
are preserved by the OCaml program. The compiler and the hardware are free to
optimize the program as long as they respect the ordering guarantees of the
memory model. While programming directly under the weak memory model is
difficult, the memory model also describes the conditions under which a program
will only exhibit sequentially consistent behaviours. This guarantee is known
as data race freedom implies sequential consistency (DRF-SC). In this section,
we shall describe this guarantee. In order to do this, we first need a number
of definitions.</p>
<h3 class="subsection" id="sec94"><a class="section-anchor" href="#sec94" aria-hidden="true">﻿</a><span class="number">2.1</span> Memory locations</h3>
<p>OCaml classifies memory locations into <em>atomic</em> and <em>non-atomic</em>
locations. Reference cells, array fields and mutable record fields are
non-atomic memory locations. Immutable objects are non-atomic locations with an
initialising write but no further updates. Atomic memory locations are those
that are created using the <a href="../api/Atomic.html"><span class="font-tt">Atomic</span></a> module.</p>
<h3 class="subsection" id="s:happens_before"><a class="section-anchor" href="#s:happens_before" aria-hidden="true">﻿</a><span class="number">2.2</span> Happens-before relation</h3>
<p>Let us imagine that the OCaml programs are executed by an abstract machine that
executes one action at a time, arbitrarily picking one of the available domains
at each step. We classify actions into two: <em>inter-domain</em> and
<em>intra-domain</em>. An inter-domain action is one which can be observed and be
influenced by actions on other domains. There are several inter-domain actions:</p><ul class="itemize"><li class="li-itemize">
Reads and writes of atomic and non-atomic locations.
</li><li class="li-itemize">Spawn and join of domains.
</li><li class="li-itemize">Operations on mutexes.
</li></ul><p><em>(TODO: Include semaphores and condition variables in inter-domain
actions.)</em></p><p>On the other hand, an intra-domain actions can neither be observed nor
influence the execution of other domains. Examples include evaluating an
arithmetic expression, calling a function, etc. The memory model specification
ignores such intra-domain actions. In the sequel, we use the term action to
indicate inter-domain actions.</p><p>A totally ordered list of actions executed by the abstract machine is called
the <em>execution trace</em>. There might be several execution traces for a given
program due to non-determinism.</p><p>For a given execution trace, we define an irreflexive, transitive
<em>happens-before relation</em> that captures the causality between actions in
the OCaml program. The happens-before relation is defined as follows:</p><ul class="itemize"><li class="li-itemize">
We define the order in which a domain executes its actions as the
<em>program order</em>. If an action <span class="machine"><span class="font-tt">x</span></span> precedes another action <span class="machine"><span class="font-tt">y</span></span> in
program order, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is an initialising write to a memory location (atomic or
otherwise) and <span class="machine"><span class="font-tt">y</span></span> is any read or write to that memory location, then <span class="machine"><span class="font-tt">x</span></span>
precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is a write to an atomic location and <span class="machine"><span class="font-tt">y</span></span> is a subsequent read or
write to that memory location in the execution trace, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span>
in happens-before order. For atomic locations, <span class="machine"><span class="font-tt">compare_and_set</span></span>,
<span class="machine"><span class="font-tt">fetch_and_add</span></span>, <span class="machine"><span class="font-tt">exchange</span></span>, <span class="machine"><span class="font-tt">incr</span></span> and <span class="machine"><span class="font-tt">decr</span></span> are considered to perform
both a read and a write.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is <span class="machine"><span class="font-tt">Domain.spawn f</span></span> and <span class="machine"><span class="font-tt">y</span></span> is the first action in the newly
spawned domain executing <span class="machine"><span class="font-tt">f</span></span>, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before
order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is the last action in a domain <span class="machine"><span class="font-tt">d</span></span> and <span class="machine"><span class="font-tt">y</span></span> is <span class="machine"><span class="font-tt">Domain.join     d</span></span>, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in happens-before order.
</li><li class="li-itemize">If <span class="machine"><span class="font-tt">x</span></span> is an unlock operation on a mutex, and <span class="machine"><span class="font-tt">y</span></span> is any subsequent
operation on the mutex in the execution trace, then <span class="machine"><span class="font-tt">x</span></span> precedes <span class="machine"><span class="font-tt">y</span></span> in
happens-before order.
</li></ul>
<h3 class="subsection" id="s:datarace"><a class="section-anchor" href="#s:datarace" aria-hidden="true">﻿</a><span class="number">2.3</span> Data race</h3>
<p>In a given trace, two actions are said to be <em>conflicting</em> if they access
the same non-atomic location, and at least one is a write.</p><p>We say that a program has a <em>data race</em> if there exists some execution
trace of the program with two conflicting actions and there does not exist a
happens-before relationship between the conflicting accesses. A program without
data races is said to be <em>correctly synchronised</em>.</p>
<h3 class="subsection" id="ss:drf_sc"><a class="section-anchor" href="#ss:drf_sc" aria-hidden="true">﻿</a><span class="number">2.4</span> DRF-SC</h3>
<p><span class="font-bold">DRF-SC guarantee:</span> A program without data races will only exhibit
sequentially consistent behaviours.</p><p>DRF-SC is a strong guarantee for the programmers. Programmers can use
sequential reasoning (executing one inter-domain action to identify whether
their program has a data race. In particular, they do not need to reason about
reorderings described in section ‍<a href="#s%3Awhy_weak_memory">10.1</a> in order to determine
whether their program has a data race. Once the determination that a particular
program is data race free is made, they do not need to worry about reorderings
in their code.</p>
<h2 class="section" id="s:drf_reasoning"><a class="section-anchor" href="#s:drf_reasoning" aria-hidden="true">﻿</a><span class="number">3</span> Reasoning with DRF-SC</h2>
<h2 class="section" id="s:local_drf"><a class="section-anchor" href="#s:local_drf" aria-hidden="true">﻿</a><span class="number">4</span> Local data race freedom</h2>
<p>OCaml memory model also guarantees that even for programs with data races,
there are no crashes.</p>
<h2 class="section" id="s:ldrf_reasoning"><a class="section-anchor" href="#s:ldrf_reasoning" aria-hidden="true">﻿</a><span class="number">5</span> Reasoning with LDRF</h2>
<h2 class="section" id="s:tearing"><a class="section-anchor" href="#s:tearing" aria-hidden="true">﻿</a><span class="number">6</span> Operations that are not memory model compliant</h2>
<ul class="itemize"><li class="li-itemize">
<span class="machine"><span class="font-tt">Array.blit</span></span> on float arrays.
</li><li class="li-itemize">32-bit flat-float arrays: Getting and setting is not an atomic operation.
</li><li class="li-itemize">Tearing with mixed-sized accesses on Bytes.
</li></ul>
<hr>
<div class="bottom-navigation"><a class="previous" href="parallelism.html">« Parallel programming</a><a class="next" href="language.html">The OCaml language »</a></div>




<div class="copyright">Copyright © 2022 Institut National de
Recherche en Informatique et en Automatique</div></div></body></html>